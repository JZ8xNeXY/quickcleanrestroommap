/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./node_modules/blueimp-load-image/js/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/index.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* global module, require */\n\nmodule.exports = __webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")\n\n__webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\")\n__webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")\n__webpack_require__(/*! ./load-image-fetch */ \"./node_modules/blueimp-load-image/js/load-image-fetch.js\")\n__webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")\n__webpack_require__(/*! ./load-image-exif-map */ \"./node_modules/blueimp-load-image/js/load-image-exif-map.js\")\n__webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")\n__webpack_require__(/*! ./load-image-iptc-map */ \"./node_modules/blueimp-load-image/js/load-image-iptc-map.js\")\n__webpack_require__(/*! ./load-image-orientation */ \"./node_modules/blueimp-load-image/js/load-image-orientation.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLDhHQUF3Qzs7QUFFeEMsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDNUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDM0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDNUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDM0IsbUJBQU8sQ0FBQywwRkFBdUI7QUFDL0IsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDM0IsbUJBQU8sQ0FBQywwRkFBdUI7QUFDL0IsbUJBQU8sQ0FBQyxnR0FBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9pbmRleC5qcz84Zjg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKVxuXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2Utc2NhbGUnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLWZldGNoJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmLW1hcCcpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0YycpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0Yy1tYXAnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW9yaWVudGF0aW9uJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/index.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif-map.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var ExifMapProto = loadImage.ExifMap.prototype\n\n  ExifMapProto.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    0x8769: {\n      // ExifIFDPointer\n      0x9000: 'ExifVersion', // EXIF version\n      0xa000: 'FlashpixVersion', // Flashpix format version\n      0xa001: 'ColorSpace', // Color space information tag\n      0xa002: 'PixelXDimension', // Valid width of meaningful image\n      0xa003: 'PixelYDimension', // Valid height of meaningful image\n      0xa500: 'Gamma',\n      0x9101: 'ComponentsConfiguration', // Information about channels\n      0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel\n      0x927c: 'MakerNote', // Any desired information written by the manufacturer\n      0x9286: 'UserComment', // Comments by user\n      0xa004: 'RelatedSoundFile', // Name of related sound file\n      0x9003: 'DateTimeOriginal', // Date and time when the original image was generated\n      0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally\n      0x9010: 'OffsetTime', // Time zone when the image file was last changed\n      0x9011: 'OffsetTimeOriginal', // Time zone when the image was stored digitally\n      0x9012: 'OffsetTimeDigitized', // Time zone when the image was stored digitally\n      0x9290: 'SubSecTime', // Fractions of seconds for DateTime\n      0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal\n      0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized\n      0x829a: 'ExposureTime', // Exposure time (in seconds)\n      0x829d: 'FNumber',\n      0x8822: 'ExposureProgram', // Exposure program\n      0x8824: 'SpectralSensitivity', // Spectral sensitivity\n      0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n      0x8828: 'OECF', // Optoelectric conversion factor\n      0x8830: 'SensitivityType',\n      0x8831: 'StandardOutputSensitivity',\n      0x8832: 'RecommendedExposureIndex',\n      0x8833: 'ISOSpeed',\n      0x8834: 'ISOSpeedLatitudeyyy',\n      0x8835: 'ISOSpeedLatitudezzz',\n      0x9201: 'ShutterSpeedValue', // Shutter speed\n      0x9202: 'ApertureValue', // Lens aperture\n      0x9203: 'BrightnessValue', // Value of brightness\n      0x9204: 'ExposureBias', // Exposure bias\n      0x9205: 'MaxApertureValue', // Smallest F number of lens\n      0x9206: 'SubjectDistance', // Distance to subject in meters\n      0x9207: 'MeteringMode', // Metering mode\n      0x9208: 'LightSource', // Kind of light source\n      0x9209: 'Flash', // Flash status\n      0x9214: 'SubjectArea', // Location and area of main subject\n      0x920a: 'FocalLength', // Focal length of the lens in mm\n      0xa20b: 'FlashEnergy', // Strobe energy in BCPS\n      0xa20c: 'SpatialFrequencyResponse',\n      0xa20e: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit\n      0xa20f: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit\n      0xa210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution\n      0xa214: 'SubjectLocation', // Location of subject in image\n      0xa215: 'ExposureIndex', // Exposure index selected on camera\n      0xa217: 'SensingMethod', // Image sensor type\n      0xa300: 'FileSource', // Image source (3 == DSC)\n      0xa301: 'SceneType', // Scene type (1 == directly photographed)\n      0xa302: 'CFAPattern', // Color filter array geometric pattern\n      0xa401: 'CustomRendered', // Special processing\n      0xa402: 'ExposureMode', // Exposure mode\n      0xa403: 'WhiteBalance', // 1 = auto white balance, 2 = manual\n      0xa404: 'DigitalZoomRatio', // Digital zoom ratio\n      0xa405: 'FocalLengthIn35mmFilm',\n      0xa406: 'SceneCaptureType', // Type of scene\n      0xa407: 'GainControl', // Degree of overall image gain adjustment\n      0xa408: 'Contrast', // Direction of contrast processing applied by camera\n      0xa409: 'Saturation', // Direction of saturation processing applied by camera\n      0xa40a: 'Sharpness', // Direction of sharpness processing applied by camera\n      0xa40b: 'DeviceSettingDescription',\n      0xa40c: 'SubjectDistanceRange', // Distance to subject\n      0xa420: 'ImageUniqueID', // Identifier assigned uniquely to each image\n      0xa430: 'CameraOwnerName',\n      0xa431: 'BodySerialNumber',\n      0xa432: 'LensSpecification',\n      0xa433: 'LensMake',\n      0xa434: 'LensModel',\n      0xa435: 'LensSerialNumber'\n    },\n    0x8825: {\n      // GPSInfoIFDPointer\n      0x0000: 'GPSVersionID',\n      0x0001: 'GPSLatitudeRef',\n      0x0002: 'GPSLatitude',\n      0x0003: 'GPSLongitudeRef',\n      0x0004: 'GPSLongitude',\n      0x0005: 'GPSAltitudeRef',\n      0x0006: 'GPSAltitude',\n      0x0007: 'GPSTimeStamp',\n      0x0008: 'GPSSatellites',\n      0x0009: 'GPSStatus',\n      0x000a: 'GPSMeasureMode',\n      0x000b: 'GPSDOP',\n      0x000c: 'GPSSpeedRef',\n      0x000d: 'GPSSpeed',\n      0x000e: 'GPSTrackRef',\n      0x000f: 'GPSTrack',\n      0x0010: 'GPSImgDirectionRef',\n      0x0011: 'GPSImgDirection',\n      0x0012: 'GPSMapDatum',\n      0x0013: 'GPSDestLatitudeRef',\n      0x0014: 'GPSDestLatitude',\n      0x0015: 'GPSDestLongitudeRef',\n      0x0016: 'GPSDestLongitude',\n      0x0017: 'GPSDestBearingRef',\n      0x0018: 'GPSDestBearing',\n      0x0019: 'GPSDestDistanceRef',\n      0x001a: 'GPSDestDistance',\n      0x001b: 'GPSProcessingMethod',\n      0x001c: 'GPSAreaInformation',\n      0x001d: 'GPSDateStamp',\n      0x001e: 'GPSDifferential',\n      0x001f: 'GPSHPositioningError'\n    },\n    0xa005: {\n      // InteroperabilityIFDPointer\n      0x0001: 'InteroperabilityIndex'\n    }\n  }\n\n  // IFD1 directory can contain any IFD0 tags:\n  ExifMapProto.tags.ifd1 = ExifMapProto.tags\n\n  ExifMapProto.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d:\n        'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f:\n        'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d:\n        'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f:\n        'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'Original',\n      2: 'Horizontal flip',\n      3: 'Rotate 180° CCW',\n      4: 'Vertical flip',\n      5: 'Vertical flip + Rotate 90° CW',\n      6: 'Rotate 90° CW',\n      7: 'Horizontal flip + Rotate 90° CW',\n      8: 'Rotate 90° CCW'\n    }\n  }\n\n  ExifMapProto.getText = function (name) {\n    var value = this.get(name)\n    switch (name) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[name][value]\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return\n        return String.fromCharCode(value[0], value[1], value[2], value[3])\n      case 'ComponentsConfiguration':\n        if (!value) return\n        return (\n          this.stringValues[name][value[0]] +\n          this.stringValues[name][value[1]] +\n          this.stringValues[name][value[2]] +\n          this.stringValues[name][value[3]]\n        )\n      case 'GPSVersionID':\n        if (!value) return\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]\n    }\n    return String(value)\n  }\n\n  ExifMapProto.getAll = function () {\n    var map = {}\n    var prop\n    var obj\n    var name\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        obj = this[prop]\n        if (obj && obj.getAll) {\n          map[this.ifds[prop].name] = obj.getAll()\n        } else {\n          name = this.tags[prop]\n          if (name) map[name] = this.getText(name)\n        }\n      }\n    }\n    return map\n  }\n\n  ExifMapProto.getName = function (tagCode) {\n    var name = this.tags[tagCode]\n    if (typeof name === 'object') return this.ifds[tagCode].name\n    return name\n  }\n\n  // Extend the map of tag names to tag codes:\n  ;(function () {\n    var tags = ExifMapProto.tags\n    var prop\n    var ifd\n    var subTags\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        ifd = ExifMapProto.ifds[prop]\n        if (ifd) {\n          subTags = tags[prop]\n          for (prop in subTags) {\n            if (Object.prototype.hasOwnProperty.call(subTags, prop)) {\n              ifd.map[subTags[prop]] = Number(prop)\n            }\n          }\n        } else {\n          ExifMapProto.map[tags[prop]] = Number(prop)\n        }\n      }\n    }\n  })()\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi1tYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDMUQsSUFBSSxLQUFLLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWV4aWYtbWFwLmpzPzE4N2MiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBFeGlmIE1hcFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBFeGlmIHRhZ3MgbWFwcGluZyBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZWlkZWxpbi9leGlmLWpzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtZXhpZiddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLWV4aWYnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBFeGlmTWFwUHJvdG8gPSBsb2FkSW1hZ2UuRXhpZk1hcC5wcm90b3R5cGVcblxuICBFeGlmTWFwUHJvdG8udGFncyA9IHtcbiAgICAvLyA9PT09PT09PT09PT09PT09PVxuICAgIC8vIFRJRkYgdGFncyAoSUZEMCk6XG4gICAgLy8gPT09PT09PT09PT09PT09PT1cbiAgICAweDAxMDA6ICdJbWFnZVdpZHRoJyxcbiAgICAweDAxMDE6ICdJbWFnZUhlaWdodCcsXG4gICAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gICAgMHgwMTAzOiAnQ29tcHJlc3Npb24nLFxuICAgIDB4MDEwNjogJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAgIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgICAweDAxMTU6ICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAgIDB4MDExYzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAgIDB4MDIxMjogJ1lDYkNyU3ViU2FtcGxpbmcnLFxuICAgIDB4MDIxMzogJ1lDYkNyUG9zaXRpb25pbmcnLFxuICAgIDB4MDExYTogJ1hSZXNvbHV0aW9uJyxcbiAgICAweDAxMWI6ICdZUmVzb2x1dGlvbicsXG4gICAgMHgwMTI4OiAnUmVzb2x1dGlvblVuaXQnLFxuICAgIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsXG4gICAgMHgwMTE2OiAnUm93c1BlclN0cmlwJyxcbiAgICAweDAxMTc6ICdTdHJpcEJ5dGVDb3VudHMnLFxuICAgIDB4MDIwMTogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdCcsXG4gICAgMHgwMjAyOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoJyxcbiAgICAweDAxMmQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgICAweDAxM2U6ICdXaGl0ZVBvaW50JyxcbiAgICAweDAxM2Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAgIDB4MDIxMTogJ1lDYkNyQ29lZmZpY2llbnRzJyxcbiAgICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgICAweDAxMzI6ICdEYXRlVGltZScsXG4gICAgMHgwMTBlOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gICAgMHgwMTBmOiAnTWFrZScsXG4gICAgMHgwMTEwOiAnTW9kZWwnLFxuICAgIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgICAweDAxM2I6ICdBcnRpc3QnLFxuICAgIDB4ODI5ODogJ0NvcHlyaWdodCcsXG4gICAgMHg4NzY5OiB7XG4gICAgICAvLyBFeGlmSUZEUG9pbnRlclxuICAgICAgMHg5MDAwOiAnRXhpZlZlcnNpb24nLCAvLyBFWElGIHZlcnNpb25cbiAgICAgIDB4YTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsIC8vIEZsYXNocGl4IGZvcm1hdCB2ZXJzaW9uXG4gICAgICAweGEwMDE6ICdDb2xvclNwYWNlJywgLy8gQ29sb3Igc3BhY2UgaW5mb3JtYXRpb24gdGFnXG4gICAgICAweGEwMDI6ICdQaXhlbFhEaW1lbnNpb24nLCAvLyBWYWxpZCB3aWR0aCBvZiBtZWFuaW5nZnVsIGltYWdlXG4gICAgICAweGEwMDM6ICdQaXhlbFlEaW1lbnNpb24nLCAvLyBWYWxpZCBoZWlnaHQgb2YgbWVhbmluZ2Z1bCBpbWFnZVxuICAgICAgMHhhNTAwOiAnR2FtbWEnLFxuICAgICAgMHg5MTAxOiAnQ29tcG9uZW50c0NvbmZpZ3VyYXRpb24nLCAvLyBJbmZvcm1hdGlvbiBhYm91dCBjaGFubmVsc1xuICAgICAgMHg5MTAyOiAnQ29tcHJlc3NlZEJpdHNQZXJQaXhlbCcsIC8vIENvbXByZXNzZWQgYml0cyBwZXIgcGl4ZWxcbiAgICAgIDB4OTI3YzogJ01ha2VyTm90ZScsIC8vIEFueSBkZXNpcmVkIGluZm9ybWF0aW9uIHdyaXR0ZW4gYnkgdGhlIG1hbnVmYWN0dXJlclxuICAgICAgMHg5Mjg2OiAnVXNlckNvbW1lbnQnLCAvLyBDb21tZW50cyBieSB1c2VyXG4gICAgICAweGEwMDQ6ICdSZWxhdGVkU291bmRGaWxlJywgLy8gTmFtZSBvZiByZWxhdGVkIHNvdW5kIGZpbGVcbiAgICAgIDB4OTAwMzogJ0RhdGVUaW1lT3JpZ2luYWwnLCAvLyBEYXRlIGFuZCB0aW1lIHdoZW4gdGhlIG9yaWdpbmFsIGltYWdlIHdhcyBnZW5lcmF0ZWRcbiAgICAgIDB4OTAwNDogJ0RhdGVUaW1lRGlnaXRpemVkJywgLy8gRGF0ZSBhbmQgdGltZSB3aGVuIHRoZSBpbWFnZSB3YXMgc3RvcmVkIGRpZ2l0YWxseVxuICAgICAgMHg5MDEwOiAnT2Zmc2V0VGltZScsIC8vIFRpbWUgem9uZSB3aGVuIHRoZSBpbWFnZSBmaWxlIHdhcyBsYXN0IGNoYW5nZWRcbiAgICAgIDB4OTAxMTogJ09mZnNldFRpbWVPcmlnaW5hbCcsIC8vIFRpbWUgem9uZSB3aGVuIHRoZSBpbWFnZSB3YXMgc3RvcmVkIGRpZ2l0YWxseVxuICAgICAgMHg5MDEyOiAnT2Zmc2V0VGltZURpZ2l0aXplZCcsIC8vIFRpbWUgem9uZSB3aGVuIHRoZSBpbWFnZSB3YXMgc3RvcmVkIGRpZ2l0YWxseVxuICAgICAgMHg5MjkwOiAnU3ViU2VjVGltZScsIC8vIEZyYWN0aW9ucyBvZiBzZWNvbmRzIGZvciBEYXRlVGltZVxuICAgICAgMHg5MjkxOiAnU3ViU2VjVGltZU9yaWdpbmFsJywgLy8gRnJhY3Rpb25zIG9mIHNlY29uZHMgZm9yIERhdGVUaW1lT3JpZ2luYWxcbiAgICAgIDB4OTI5MjogJ1N1YlNlY1RpbWVEaWdpdGl6ZWQnLCAvLyBGcmFjdGlvbnMgb2Ygc2Vjb25kcyBmb3IgRGF0ZVRpbWVEaWdpdGl6ZWRcbiAgICAgIDB4ODI5YTogJ0V4cG9zdXJlVGltZScsIC8vIEV4cG9zdXJlIHRpbWUgKGluIHNlY29uZHMpXG4gICAgICAweDgyOWQ6ICdGTnVtYmVyJyxcbiAgICAgIDB4ODgyMjogJ0V4cG9zdXJlUHJvZ3JhbScsIC8vIEV4cG9zdXJlIHByb2dyYW1cbiAgICAgIDB4ODgyNDogJ1NwZWN0cmFsU2Vuc2l0aXZpdHknLCAvLyBTcGVjdHJhbCBzZW5zaXRpdml0eVxuICAgICAgMHg4ODI3OiAnUGhvdG9ncmFwaGljU2Vuc2l0aXZpdHknLCAvLyBFWElGIDIuMywgSVNPU3BlZWRSYXRpbmdzIGluIEVYSUYgMi4yXG4gICAgICAweDg4Mjg6ICdPRUNGJywgLy8gT3B0b2VsZWN0cmljIGNvbnZlcnNpb24gZmFjdG9yXG4gICAgICAweDg4MzA6ICdTZW5zaXRpdml0eVR5cGUnLFxuICAgICAgMHg4ODMxOiAnU3RhbmRhcmRPdXRwdXRTZW5zaXRpdml0eScsXG4gICAgICAweDg4MzI6ICdSZWNvbW1lbmRlZEV4cG9zdXJlSW5kZXgnLFxuICAgICAgMHg4ODMzOiAnSVNPU3BlZWQnLFxuICAgICAgMHg4ODM0OiAnSVNPU3BlZWRMYXRpdHVkZXl5eScsXG4gICAgICAweDg4MzU6ICdJU09TcGVlZExhdGl0dWRlenp6JyxcbiAgICAgIDB4OTIwMTogJ1NodXR0ZXJTcGVlZFZhbHVlJywgLy8gU2h1dHRlciBzcGVlZFxuICAgICAgMHg5MjAyOiAnQXBlcnR1cmVWYWx1ZScsIC8vIExlbnMgYXBlcnR1cmVcbiAgICAgIDB4OTIwMzogJ0JyaWdodG5lc3NWYWx1ZScsIC8vIFZhbHVlIG9mIGJyaWdodG5lc3NcbiAgICAgIDB4OTIwNDogJ0V4cG9zdXJlQmlhcycsIC8vIEV4cG9zdXJlIGJpYXNcbiAgICAgIDB4OTIwNTogJ01heEFwZXJ0dXJlVmFsdWUnLCAvLyBTbWFsbGVzdCBGIG51bWJlciBvZiBsZW5zXG4gICAgICAweDkyMDY6ICdTdWJqZWN0RGlzdGFuY2UnLCAvLyBEaXN0YW5jZSB0byBzdWJqZWN0IGluIG1ldGVyc1xuICAgICAgMHg5MjA3OiAnTWV0ZXJpbmdNb2RlJywgLy8gTWV0ZXJpbmcgbW9kZVxuICAgICAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLCAvLyBLaW5kIG9mIGxpZ2h0IHNvdXJjZVxuICAgICAgMHg5MjA5OiAnRmxhc2gnLCAvLyBGbGFzaCBzdGF0dXNcbiAgICAgIDB4OTIxNDogJ1N1YmplY3RBcmVhJywgLy8gTG9jYXRpb24gYW5kIGFyZWEgb2YgbWFpbiBzdWJqZWN0XG4gICAgICAweDkyMGE6ICdGb2NhbExlbmd0aCcsIC8vIEZvY2FsIGxlbmd0aCBvZiB0aGUgbGVucyBpbiBtbVxuICAgICAgMHhhMjBiOiAnRmxhc2hFbmVyZ3knLCAvLyBTdHJvYmUgZW5lcmd5IGluIEJDUFNcbiAgICAgIDB4YTIwYzogJ1NwYXRpYWxGcmVxdWVuY3lSZXNwb25zZScsXG4gICAgICAweGEyMGU6ICdGb2NhbFBsYW5lWFJlc29sdXRpb24nLCAvLyBOdW1iZXIgb2YgcGl4ZWxzIGluIHdpZHRoIGRpcmVjdGlvbiBwZXIgRlBSVW5pdFxuICAgICAgMHhhMjBmOiAnRm9jYWxQbGFuZVlSZXNvbHV0aW9uJywgLy8gTnVtYmVyIG9mIHBpeGVscyBpbiBoZWlnaHQgZGlyZWN0aW9uIHBlciBGUFJVbml0XG4gICAgICAweGEyMTA6ICdGb2NhbFBsYW5lUmVzb2x1dGlvblVuaXQnLCAvLyBVbml0IGZvciBtZWFzdXJpbmcgdGhlIGZvY2FsIHBsYW5lIHJlc29sdXRpb25cbiAgICAgIDB4YTIxNDogJ1N1YmplY3RMb2NhdGlvbicsIC8vIExvY2F0aW9uIG9mIHN1YmplY3QgaW4gaW1hZ2VcbiAgICAgIDB4YTIxNTogJ0V4cG9zdXJlSW5kZXgnLCAvLyBFeHBvc3VyZSBpbmRleCBzZWxlY3RlZCBvbiBjYW1lcmFcbiAgICAgIDB4YTIxNzogJ1NlbnNpbmdNZXRob2QnLCAvLyBJbWFnZSBzZW5zb3IgdHlwZVxuICAgICAgMHhhMzAwOiAnRmlsZVNvdXJjZScsIC8vIEltYWdlIHNvdXJjZSAoMyA9PSBEU0MpXG4gICAgICAweGEzMDE6ICdTY2VuZVR5cGUnLCAvLyBTY2VuZSB0eXBlICgxID09IGRpcmVjdGx5IHBob3RvZ3JhcGhlZClcbiAgICAgIDB4YTMwMjogJ0NGQVBhdHRlcm4nLCAvLyBDb2xvciBmaWx0ZXIgYXJyYXkgZ2VvbWV0cmljIHBhdHRlcm5cbiAgICAgIDB4YTQwMTogJ0N1c3RvbVJlbmRlcmVkJywgLy8gU3BlY2lhbCBwcm9jZXNzaW5nXG4gICAgICAweGE0MDI6ICdFeHBvc3VyZU1vZGUnLCAvLyBFeHBvc3VyZSBtb2RlXG4gICAgICAweGE0MDM6ICdXaGl0ZUJhbGFuY2UnLCAvLyAxID0gYXV0byB3aGl0ZSBiYWxhbmNlLCAyID0gbWFudWFsXG4gICAgICAweGE0MDQ6ICdEaWdpdGFsWm9vbVJhdGlvJywgLy8gRGlnaXRhbCB6b29tIHJhdGlvXG4gICAgICAweGE0MDU6ICdGb2NhbExlbmd0aEluMzVtbUZpbG0nLFxuICAgICAgMHhhNDA2OiAnU2NlbmVDYXB0dXJlVHlwZScsIC8vIFR5cGUgb2Ygc2NlbmVcbiAgICAgIDB4YTQwNzogJ0dhaW5Db250cm9sJywgLy8gRGVncmVlIG9mIG92ZXJhbGwgaW1hZ2UgZ2FpbiBhZGp1c3RtZW50XG4gICAgICAweGE0MDg6ICdDb250cmFzdCcsIC8vIERpcmVjdGlvbiBvZiBjb250cmFzdCBwcm9jZXNzaW5nIGFwcGxpZWQgYnkgY2FtZXJhXG4gICAgICAweGE0MDk6ICdTYXR1cmF0aW9uJywgLy8gRGlyZWN0aW9uIG9mIHNhdHVyYXRpb24gcHJvY2Vzc2luZyBhcHBsaWVkIGJ5IGNhbWVyYVxuICAgICAgMHhhNDBhOiAnU2hhcnBuZXNzJywgLy8gRGlyZWN0aW9uIG9mIHNoYXJwbmVzcyBwcm9jZXNzaW5nIGFwcGxpZWQgYnkgY2FtZXJhXG4gICAgICAweGE0MGI6ICdEZXZpY2VTZXR0aW5nRGVzY3JpcHRpb24nLFxuICAgICAgMHhhNDBjOiAnU3ViamVjdERpc3RhbmNlUmFuZ2UnLCAvLyBEaXN0YW5jZSB0byBzdWJqZWN0XG4gICAgICAweGE0MjA6ICdJbWFnZVVuaXF1ZUlEJywgLy8gSWRlbnRpZmllciBhc3NpZ25lZCB1bmlxdWVseSB0byBlYWNoIGltYWdlXG4gICAgICAweGE0MzA6ICdDYW1lcmFPd25lck5hbWUnLFxuICAgICAgMHhhNDMxOiAnQm9keVNlcmlhbE51bWJlcicsXG4gICAgICAweGE0MzI6ICdMZW5zU3BlY2lmaWNhdGlvbicsXG4gICAgICAweGE0MzM6ICdMZW5zTWFrZScsXG4gICAgICAweGE0MzQ6ICdMZW5zTW9kZWwnLFxuICAgICAgMHhhNDM1OiAnTGVuc1NlcmlhbE51bWJlcidcbiAgICB9LFxuICAgIDB4ODgyNToge1xuICAgICAgLy8gR1BTSW5mb0lGRFBvaW50ZXJcbiAgICAgIDB4MDAwMDogJ0dQU1ZlcnNpb25JRCcsXG4gICAgICAweDAwMDE6ICdHUFNMYXRpdHVkZVJlZicsXG4gICAgICAweDAwMDI6ICdHUFNMYXRpdHVkZScsXG4gICAgICAweDAwMDM6ICdHUFNMb25naXR1ZGVSZWYnLFxuICAgICAgMHgwMDA0OiAnR1BTTG9uZ2l0dWRlJyxcbiAgICAgIDB4MDAwNTogJ0dQU0FsdGl0dWRlUmVmJyxcbiAgICAgIDB4MDAwNjogJ0dQU0FsdGl0dWRlJyxcbiAgICAgIDB4MDAwNzogJ0dQU1RpbWVTdGFtcCcsXG4gICAgICAweDAwMDg6ICdHUFNTYXRlbGxpdGVzJyxcbiAgICAgIDB4MDAwOTogJ0dQU1N0YXR1cycsXG4gICAgICAweDAwMGE6ICdHUFNNZWFzdXJlTW9kZScsXG4gICAgICAweDAwMGI6ICdHUFNET1AnLFxuICAgICAgMHgwMDBjOiAnR1BTU3BlZWRSZWYnLFxuICAgICAgMHgwMDBkOiAnR1BTU3BlZWQnLFxuICAgICAgMHgwMDBlOiAnR1BTVHJhY2tSZWYnLFxuICAgICAgMHgwMDBmOiAnR1BTVHJhY2snLFxuICAgICAgMHgwMDEwOiAnR1BTSW1nRGlyZWN0aW9uUmVmJyxcbiAgICAgIDB4MDAxMTogJ0dQU0ltZ0RpcmVjdGlvbicsXG4gICAgICAweDAwMTI6ICdHUFNNYXBEYXR1bScsXG4gICAgICAweDAwMTM6ICdHUFNEZXN0TGF0aXR1ZGVSZWYnLFxuICAgICAgMHgwMDE0OiAnR1BTRGVzdExhdGl0dWRlJyxcbiAgICAgIDB4MDAxNTogJ0dQU0Rlc3RMb25naXR1ZGVSZWYnLFxuICAgICAgMHgwMDE2OiAnR1BTRGVzdExvbmdpdHVkZScsXG4gICAgICAweDAwMTc6ICdHUFNEZXN0QmVhcmluZ1JlZicsXG4gICAgICAweDAwMTg6ICdHUFNEZXN0QmVhcmluZycsXG4gICAgICAweDAwMTk6ICdHUFNEZXN0RGlzdGFuY2VSZWYnLFxuICAgICAgMHgwMDFhOiAnR1BTRGVzdERpc3RhbmNlJyxcbiAgICAgIDB4MDAxYjogJ0dQU1Byb2Nlc3NpbmdNZXRob2QnLFxuICAgICAgMHgwMDFjOiAnR1BTQXJlYUluZm9ybWF0aW9uJyxcbiAgICAgIDB4MDAxZDogJ0dQU0RhdGVTdGFtcCcsXG4gICAgICAweDAwMWU6ICdHUFNEaWZmZXJlbnRpYWwnLFxuICAgICAgMHgwMDFmOiAnR1BTSFBvc2l0aW9uaW5nRXJyb3InXG4gICAgfSxcbiAgICAweGEwMDU6IHtcbiAgICAgIC8vIEludGVyb3BlcmFiaWxpdHlJRkRQb2ludGVyXG4gICAgICAweDAwMDE6ICdJbnRlcm9wZXJhYmlsaXR5SW5kZXgnXG4gICAgfVxuICB9XG5cbiAgLy8gSUZEMSBkaXJlY3RvcnkgY2FuIGNvbnRhaW4gYW55IElGRDAgdGFnczpcbiAgRXhpZk1hcFByb3RvLnRhZ3MuaWZkMSA9IEV4aWZNYXBQcm90by50YWdzXG5cbiAgRXhpZk1hcFByb3RvLnN0cmluZ1ZhbHVlcyA9IHtcbiAgICBFeHBvc3VyZVByb2dyYW06IHtcbiAgICAgIDA6ICdVbmRlZmluZWQnLFxuICAgICAgMTogJ01hbnVhbCcsXG4gICAgICAyOiAnTm9ybWFsIHByb2dyYW0nLFxuICAgICAgMzogJ0FwZXJ0dXJlIHByaW9yaXR5JyxcbiAgICAgIDQ6ICdTaHV0dGVyIHByaW9yaXR5JyxcbiAgICAgIDU6ICdDcmVhdGl2ZSBwcm9ncmFtJyxcbiAgICAgIDY6ICdBY3Rpb24gcHJvZ3JhbScsXG4gICAgICA3OiAnUG9ydHJhaXQgbW9kZScsXG4gICAgICA4OiAnTGFuZHNjYXBlIG1vZGUnXG4gICAgfSxcbiAgICBNZXRlcmluZ01vZGU6IHtcbiAgICAgIDA6ICdVbmtub3duJyxcbiAgICAgIDE6ICdBdmVyYWdlJyxcbiAgICAgIDI6ICdDZW50ZXJXZWlnaHRlZEF2ZXJhZ2UnLFxuICAgICAgMzogJ1Nwb3QnLFxuICAgICAgNDogJ011bHRpU3BvdCcsXG4gICAgICA1OiAnUGF0dGVybicsXG4gICAgICA2OiAnUGFydGlhbCcsXG4gICAgICAyNTU6ICdPdGhlcidcbiAgICB9LFxuICAgIExpZ2h0U291cmNlOiB7XG4gICAgICAwOiAnVW5rbm93bicsXG4gICAgICAxOiAnRGF5bGlnaHQnLFxuICAgICAgMjogJ0ZsdW9yZXNjZW50JyxcbiAgICAgIDM6ICdUdW5nc3RlbiAoaW5jYW5kZXNjZW50IGxpZ2h0KScsXG4gICAgICA0OiAnRmxhc2gnLFxuICAgICAgOTogJ0ZpbmUgd2VhdGhlcicsXG4gICAgICAxMDogJ0Nsb3VkeSB3ZWF0aGVyJyxcbiAgICAgIDExOiAnU2hhZGUnLFxuICAgICAgMTI6ICdEYXlsaWdodCBmbHVvcmVzY2VudCAoRCA1NzAwIC0gNzEwMEspJyxcbiAgICAgIDEzOiAnRGF5IHdoaXRlIGZsdW9yZXNjZW50IChOIDQ2MDAgLSA1NDAwSyknLFxuICAgICAgMTQ6ICdDb29sIHdoaXRlIGZsdW9yZXNjZW50IChXIDM5MDAgLSA0NTAwSyknLFxuICAgICAgMTU6ICdXaGl0ZSBmbHVvcmVzY2VudCAoV1cgMzIwMCAtIDM3MDBLKScsXG4gICAgICAxNzogJ1N0YW5kYXJkIGxpZ2h0IEEnLFxuICAgICAgMTg6ICdTdGFuZGFyZCBsaWdodCBCJyxcbiAgICAgIDE5OiAnU3RhbmRhcmQgbGlnaHQgQycsXG4gICAgICAyMDogJ0Q1NScsXG4gICAgICAyMTogJ0Q2NScsXG4gICAgICAyMjogJ0Q3NScsXG4gICAgICAyMzogJ0Q1MCcsXG4gICAgICAyNDogJ0lTTyBzdHVkaW8gdHVuZ3N0ZW4nLFxuICAgICAgMjU1OiAnT3RoZXInXG4gICAgfSxcbiAgICBGbGFzaDoge1xuICAgICAgMHgwMDAwOiAnRmxhc2ggZGlkIG5vdCBmaXJlJyxcbiAgICAgIDB4MDAwMTogJ0ZsYXNoIGZpcmVkJyxcbiAgICAgIDB4MDAwNTogJ1N0cm9iZSByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDAwNzogJ1N0cm9iZSByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDA5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG4gICAgICAweDAwMGQ6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDAwZjogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwMTA6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG4gICAgICAweDAwMTg6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGF1dG8gbW9kZScsXG4gICAgICAweDAwMTk6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlJyxcbiAgICAgIDB4MDAxZDogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDFmOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAgIDB4MDAyMDogJ05vIGZsYXNoIGZ1bmN0aW9uJyxcbiAgICAgIDB4MDA0MTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAgIDB4MDA0NTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDA0NzogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDQ5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG4gICAgICAweDAwNGQ6XG4gICAgICAgICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDA0ZjpcbiAgICAgICAgJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwNTk6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAgIDB4MDA1ZDpcbiAgICAgICAgJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuICAgICAgMHgwMDVmOlxuICAgICAgICAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJ1xuICAgIH0sXG4gICAgU2Vuc2luZ01ldGhvZDoge1xuICAgICAgMTogJ1VuZGVmaW5lZCcsXG4gICAgICAyOiAnT25lLWNoaXAgY29sb3IgYXJlYSBzZW5zb3InLFxuICAgICAgMzogJ1R3by1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJyxcbiAgICAgIDQ6ICdUaHJlZS1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJyxcbiAgICAgIDU6ICdDb2xvciBzZXF1ZW50aWFsIGFyZWEgc2Vuc29yJyxcbiAgICAgIDc6ICdUcmlsaW5lYXIgc2Vuc29yJyxcbiAgICAgIDg6ICdDb2xvciBzZXF1ZW50aWFsIGxpbmVhciBzZW5zb3InXG4gICAgfSxcbiAgICBTY2VuZUNhcHR1cmVUeXBlOiB7XG4gICAgICAwOiAnU3RhbmRhcmQnLFxuICAgICAgMTogJ0xhbmRzY2FwZScsXG4gICAgICAyOiAnUG9ydHJhaXQnLFxuICAgICAgMzogJ05pZ2h0IHNjZW5lJ1xuICAgIH0sXG4gICAgU2NlbmVUeXBlOiB7XG4gICAgICAxOiAnRGlyZWN0bHkgcGhvdG9ncmFwaGVkJ1xuICAgIH0sXG4gICAgQ3VzdG9tUmVuZGVyZWQ6IHtcbiAgICAgIDA6ICdOb3JtYWwgcHJvY2VzcycsXG4gICAgICAxOiAnQ3VzdG9tIHByb2Nlc3MnXG4gICAgfSxcbiAgICBXaGl0ZUJhbGFuY2U6IHtcbiAgICAgIDA6ICdBdXRvIHdoaXRlIGJhbGFuY2UnLFxuICAgICAgMTogJ01hbnVhbCB3aGl0ZSBiYWxhbmNlJ1xuICAgIH0sXG4gICAgR2FpbkNvbnRyb2w6IHtcbiAgICAgIDA6ICdOb25lJyxcbiAgICAgIDE6ICdMb3cgZ2FpbiB1cCcsXG4gICAgICAyOiAnSGlnaCBnYWluIHVwJyxcbiAgICAgIDM6ICdMb3cgZ2FpbiBkb3duJyxcbiAgICAgIDQ6ICdIaWdoIGdhaW4gZG93bidcbiAgICB9LFxuICAgIENvbnRyYXN0OiB7XG4gICAgICAwOiAnTm9ybWFsJyxcbiAgICAgIDE6ICdTb2Z0JyxcbiAgICAgIDI6ICdIYXJkJ1xuICAgIH0sXG4gICAgU2F0dXJhdGlvbjoge1xuICAgICAgMDogJ05vcm1hbCcsXG4gICAgICAxOiAnTG93IHNhdHVyYXRpb24nLFxuICAgICAgMjogJ0hpZ2ggc2F0dXJhdGlvbidcbiAgICB9LFxuICAgIFNoYXJwbmVzczoge1xuICAgICAgMDogJ05vcm1hbCcsXG4gICAgICAxOiAnU29mdCcsXG4gICAgICAyOiAnSGFyZCdcbiAgICB9LFxuICAgIFN1YmplY3REaXN0YW5jZVJhbmdlOiB7XG4gICAgICAwOiAnVW5rbm93bicsXG4gICAgICAxOiAnTWFjcm8nLFxuICAgICAgMjogJ0Nsb3NlIHZpZXcnLFxuICAgICAgMzogJ0Rpc3RhbnQgdmlldydcbiAgICB9LFxuICAgIEZpbGVTb3VyY2U6IHtcbiAgICAgIDM6ICdEU0MnXG4gICAgfSxcbiAgICBDb21wb25lbnRzQ29uZmlndXJhdGlvbjoge1xuICAgICAgMDogJycsXG4gICAgICAxOiAnWScsXG4gICAgICAyOiAnQ2InLFxuICAgICAgMzogJ0NyJyxcbiAgICAgIDQ6ICdSJyxcbiAgICAgIDU6ICdHJyxcbiAgICAgIDY6ICdCJ1xuICAgIH0sXG4gICAgT3JpZW50YXRpb246IHtcbiAgICAgIDE6ICdPcmlnaW5hbCcsXG4gICAgICAyOiAnSG9yaXpvbnRhbCBmbGlwJyxcbiAgICAgIDM6ICdSb3RhdGUgMTgwwrAgQ0NXJyxcbiAgICAgIDQ6ICdWZXJ0aWNhbCBmbGlwJyxcbiAgICAgIDU6ICdWZXJ0aWNhbCBmbGlwICsgUm90YXRlIDkwwrAgQ1cnLFxuICAgICAgNjogJ1JvdGF0ZSA5MMKwIENXJyxcbiAgICAgIDc6ICdIb3Jpem9udGFsIGZsaXAgKyBSb3RhdGUgOTDCsCBDVycsXG4gICAgICA4OiAnUm90YXRlIDkwwrAgQ0NXJ1xuICAgIH1cbiAgfVxuXG4gIEV4aWZNYXBQcm90by5nZXRUZXh0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChuYW1lKVxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnTGlnaHRTb3VyY2UnOlxuICAgICAgY2FzZSAnRmxhc2gnOlxuICAgICAgY2FzZSAnTWV0ZXJpbmdNb2RlJzpcbiAgICAgIGNhc2UgJ0V4cG9zdXJlUHJvZ3JhbSc6XG4gICAgICBjYXNlICdTZW5zaW5nTWV0aG9kJzpcbiAgICAgIGNhc2UgJ1NjZW5lQ2FwdHVyZVR5cGUnOlxuICAgICAgY2FzZSAnU2NlbmVUeXBlJzpcbiAgICAgIGNhc2UgJ0N1c3RvbVJlbmRlcmVkJzpcbiAgICAgIGNhc2UgJ1doaXRlQmFsYW5jZSc6XG4gICAgICBjYXNlICdHYWluQ29udHJvbCc6XG4gICAgICBjYXNlICdDb250cmFzdCc6XG4gICAgICBjYXNlICdTYXR1cmF0aW9uJzpcbiAgICAgIGNhc2UgJ1NoYXJwbmVzcyc6XG4gICAgICBjYXNlICdTdWJqZWN0RGlzdGFuY2VSYW5nZSc6XG4gICAgICBjYXNlICdGaWxlU291cmNlJzpcbiAgICAgIGNhc2UgJ09yaWVudGF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVmFsdWVzW25hbWVdW3ZhbHVlXVxuICAgICAgY2FzZSAnRXhpZlZlcnNpb24nOlxuICAgICAgY2FzZSAnRmxhc2hwaXhWZXJzaW9uJzpcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdKVxuICAgICAgY2FzZSAnQ29tcG9uZW50c0NvbmZpZ3VyYXRpb24nOlxuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLnN0cmluZ1ZhbHVlc1tuYW1lXVt2YWx1ZVswXV0gK1xuICAgICAgICAgIHRoaXMuc3RyaW5nVmFsdWVzW25hbWVdW3ZhbHVlWzFdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbbmFtZV1bdmFsdWVbMl1dICtcbiAgICAgICAgICB0aGlzLnN0cmluZ1ZhbHVlc1tuYW1lXVt2YWx1ZVszXV1cbiAgICAgICAgKVxuICAgICAgY2FzZSAnR1BTVmVyc2lvbklEJzpcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuXG4gICAgICAgIHJldHVybiB2YWx1ZVswXSArICcuJyArIHZhbHVlWzFdICsgJy4nICsgdmFsdWVbMl0gKyAnLicgKyB2YWx1ZVszXVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICB9XG5cbiAgRXhpZk1hcFByb3RvLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFwID0ge31cbiAgICB2YXIgcHJvcFxuICAgIHZhciBvYmpcbiAgICB2YXIgbmFtZVxuICAgIGZvciAocHJvcCBpbiB0aGlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3ApKSB7XG4gICAgICAgIG9iaiA9IHRoaXNbcHJvcF1cbiAgICAgICAgaWYgKG9iaiAmJiBvYmouZ2V0QWxsKSB7XG4gICAgICAgICAgbWFwW3RoaXMuaWZkc1twcm9wXS5uYW1lXSA9IG9iai5nZXRBbGwoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRhZ3NbcHJvcF1cbiAgICAgICAgICBpZiAobmFtZSkgbWFwW25hbWVdID0gdGhpcy5nZXRUZXh0KG5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgRXhpZk1hcFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAodGFnQ29kZSkge1xuICAgIHZhciBuYW1lID0gdGhpcy50YWdzW3RhZ0NvZGVdXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgcmV0dXJuIHRoaXMuaWZkc1t0YWdDb2RlXS5uYW1lXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgbWFwIG9mIHRhZyBuYW1lcyB0byB0YWcgY29kZXM6XG4gIDsoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YWdzID0gRXhpZk1hcFByb3RvLnRhZ3NcbiAgICB2YXIgcHJvcFxuICAgIHZhciBpZmRcbiAgICB2YXIgc3ViVGFnc1xuICAgIC8vIE1hcCB0aGUgdGFnIG5hbWVzIHRvIHRhZ3M6XG4gICAgZm9yIChwcm9wIGluIHRhZ3MpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFncywgcHJvcCkpIHtcbiAgICAgICAgaWZkID0gRXhpZk1hcFByb3RvLmlmZHNbcHJvcF1cbiAgICAgICAgaWYgKGlmZCkge1xuICAgICAgICAgIHN1YlRhZ3MgPSB0YWdzW3Byb3BdXG4gICAgICAgICAgZm9yIChwcm9wIGluIHN1YlRhZ3MpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3ViVGFncywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgaWZkLm1hcFtzdWJUYWdzW3Byb3BdXSA9IE51bWJlcihwcm9wKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBFeGlmTWFwUHJvdG8ubWFwW3RhZ3NbcHJvcF1dID0gTnVtYmVyKHByb3ApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pKClcbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif-map.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n/* eslint-disable no-console */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  /**\n   * Exif tag map\n   *\n   * @name ExifMap\n   * @class\n   * @param {number|string} tagCode IFD tag code\n   */\n  function ExifMap(tagCode) {\n    if (tagCode) {\n      Object.defineProperty(this, 'map', {\n        value: this.ifds[tagCode].map\n      })\n      Object.defineProperty(this, 'tags', {\n        value: (this.tags && this.tags[tagCode]) || {}\n      })\n    }\n  }\n\n  ExifMap.prototype.map = {\n    Orientation: 0x0112,\n    Thumbnail: 'ifd1',\n    Blob: 0x0201, // Alias for JPEGInterchangeFormat\n    Exif: 0x8769,\n    GPSInfo: 0x8825,\n    Interoperability: 0xa005\n  }\n\n  ExifMap.prototype.ifds = {\n    ifd1: { name: 'Thumbnail', map: ExifMap.prototype.map },\n    0x8769: { name: 'Exif', map: {} },\n    0x8825: { name: 'GPSInfo', map: {} },\n    0xa005: { name: 'Interoperability', map: {} }\n  }\n\n  /**\n   * Retrieves exif tag value\n   *\n   * @param {number|string} id Exif tag code or name\n   * @returns {object} Exif tag value\n   */\n  ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  /**\n   * Returns the Exif Thumbnail data as Blob.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Thumbnail data offset\n   * @param {number} length Thumbnail data length\n   * @returns {undefined|Blob} Returns the Thumbnail Blob or undefined\n   */\n  function getExifThumbnail(dataView, offset, length) {\n    if (!length) return\n    if (offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.')\n      return\n    }\n    return new Blob(\n      [loadImage.bufferSlice.call(dataView.buffer, offset, offset + length)],\n      {\n        type: 'image/jpeg'\n      }\n    )\n  }\n\n  var ExifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function (dataView, dataOffset) {\n        return dataView.getUint8(dataOffset)\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function (dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset))\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian)\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getUint32(dataOffset, littleEndian) /\n          dataView.getUint32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getInt32(dataOffset, littleEndian) /\n          dataView.getInt32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    }\n  }\n  // undefined, 8-bit byte, value depending on field:\n  ExifTagTypes[7] = ExifTagTypes[1]\n\n  /**\n   * Returns Exif tag value.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {number} offset Tag offset\n   * @param {number} type Tag type\n   * @param {number} length Tag length\n   * @param {boolean} littleEndian Little endian encoding\n   * @returns {object} Tag value\n   */\n  function getExifValue(\n    dataView,\n    tiffOffset,\n    offset,\n    type,\n    length,\n    littleEndian\n  ) {\n    var tagType = ExifTagTypes[type]\n    var tagSize\n    var dataOffset\n    var values\n    var i\n    var str\n    var c\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.')\n      return\n    }\n    tagSize = tagType.size * length\n    // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n    dataOffset =\n      tagSize > 4\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\n        : offset + 8\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.')\n      return\n    }\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian)\n    }\n    values = []\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(\n        dataView,\n        dataOffset + i * tagType.size,\n        littleEndian\n      )\n    }\n    if (tagType.ascii) {\n      str = ''\n      // Concatenate the chars:\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]\n        // Ignore the terminating NULL byte(s):\n        if (c === '\\u0000') {\n          break\n        }\n        str += c\n      }\n      return str\n    }\n    return values\n  }\n\n  /**\n   * Determines if the given tag should be included.\n   *\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   * @param {number|string} tagCode Tag code to check\n   * @returns {boolean} True if the tag should be included\n   */\n  function shouldIncludeTag(includeTags, excludeTags, tagCode) {\n    return (\n      (!includeTags || includeTags[tagCode]) &&\n      (!excludeTags || excludeTags[tagCode] !== true)\n    )\n  }\n\n  /**\n   * Parses Exif tags.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {number} dirOffset Directory offset\n   * @param {boolean} littleEndian Little endian encoding\n   * @param {ExifMap} tags Map to store parsed exif tags\n   * @param {ExifMap} tagOffsets Map to store parsed exif tag offsets\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   * @returns {number} Next directory offset\n   */\n  function parseExifTags(\n    dataView,\n    tiffOffset,\n    dirOffset,\n    littleEndian,\n    tags,\n    tagOffsets,\n    includeTags,\n    excludeTags\n  ) {\n    var tagsNumber, dirEndOffset, i, tagOffset, tagNumber, tagValue\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.')\n      return\n    }\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.')\n      return\n    }\n    for (i = 0; i < tagsNumber; i += 1) {\n      tagOffset = dirOffset + 2 + 12 * i\n      tagNumber = dataView.getUint16(tagOffset, littleEndian)\n      if (!shouldIncludeTag(includeTags, excludeTags, tagNumber)) continue\n      tagValue = getExifValue(\n        dataView,\n        tiffOffset,\n        tagOffset,\n        dataView.getUint16(tagOffset + 2, littleEndian), // tag type\n        dataView.getUint32(tagOffset + 4, littleEndian), // tag length\n        littleEndian\n      )\n      tags[tagNumber] = tagValue\n      if (tagOffsets) {\n        tagOffsets[tagNumber] = tagOffset\n      }\n    }\n    // Return the offset to the next directory:\n    return dataView.getUint32(dirEndOffset, littleEndian)\n  }\n\n  /**\n   * Parses tags in a given IFD (Image File Directory).\n   *\n   * @param {object} data Data object to store exif tags and offsets\n   * @param {number|string} tagCode IFD tag code\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {boolean} littleEndian Little endian encoding\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   */\n  function parseExifIFD(\n    data,\n    tagCode,\n    dataView,\n    tiffOffset,\n    littleEndian,\n    includeTags,\n    excludeTags\n  ) {\n    var dirOffset = data.exif[tagCode]\n    if (dirOffset) {\n      data.exif[tagCode] = new ExifMap(tagCode)\n      if (data.exifOffsets) {\n        data.exifOffsets[tagCode] = new ExifMap(tagCode)\n      }\n      parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + dirOffset,\n        littleEndian,\n        data.exif[tagCode],\n        data.exifOffsets && data.exifOffsets[tagCode],\n        includeTags && includeTags[tagCode],\n        excludeTags && excludeTags[tagCode]\n      )\n    }\n  }\n\n  loadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return\n    }\n    var includeTags = options.includeExifTags\n    var excludeTags = options.excludeExifTags || {\n      0x8769: {\n        // ExifIFDPointer\n        0x927c: true // MakerNote\n      }\n    }\n    var tiffOffset = offset + 10\n    var littleEndian\n    var dirOffset\n    var thumbnailIFD\n    // Check for the ASCII code for \"Exif\" (0x45786966):\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return\n    }\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.')\n      return\n    }\n    // Check for the two null bytes:\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.')\n      return\n    }\n    // Check the byte alignment:\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true\n        break\n      case 0x4d4d:\n        littleEndian = false\n        break\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\n        return\n    }\n    // Check for the TIFF tag marker (0x002A):\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.')\n      return\n    }\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\n    // Create the exif object to store the tags:\n    data.exif = new ExifMap()\n    if (!options.disableExifOffsets) {\n      data.exifOffsets = new ExifMap()\n      data.exifTiffOffset = tiffOffset\n      data.exifLittleEndian = littleEndian\n    }\n    // Parse the tags of the main image directory (IFD0) and retrieve the\n    // offset to the next directory (IFD1), usually the thumbnail directory:\n    dirOffset = parseExifTags(\n      dataView,\n      tiffOffset,\n      tiffOffset + dirOffset,\n      littleEndian,\n      data.exif,\n      data.exifOffsets,\n      includeTags,\n      excludeTags\n    )\n    if (dirOffset && shouldIncludeTag(includeTags, excludeTags, 'ifd1')) {\n      data.exif.ifd1 = dirOffset\n      if (data.exifOffsets) {\n        data.exifOffsets.ifd1 = tiffOffset + dirOffset\n      }\n    }\n    Object.keys(data.exif.ifds).forEach(function (tagCode) {\n      parseExifIFD(\n        data,\n        tagCode,\n        dataView,\n        tiffOffset,\n        littleEndian,\n        includeTags,\n        excludeTags\n      )\n    })\n    thumbnailIFD = data.exif.ifd1\n    // Check for JPEG Thumbnail offset and data length:\n    if (thumbnailIFD && thumbnailIFD[0x0201]) {\n      thumbnailIFD[0x0201] = getExifThumbnail(\n        dataView,\n        tiffOffset + thumbnailIFD[0x0201],\n        thumbnailIFD[0x0202] // Thumbnail data length\n      )\n    }\n  }\n\n  // Registers the Exif parser for the APP1 JPEG metadata segment:\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)\n\n  loadImage.exifWriters = {\n    // Orientation writer:\n    0x0112: function (buffer, data, value) {\n      var orientationOffset = data.exifOffsets[0x0112]\n      if (!orientationOffset) return buffer\n      var view = new DataView(buffer, orientationOffset + 8, 2)\n      view.setUint16(0, value, data.exifLittleEndian)\n      return buffer\n    }\n  }\n\n  loadImage.writeExifData = function (buffer, data, id, value) {\n    return loadImage.exifWriters[data.exif.map[id]](buffer, data, value)\n  }\n\n  loadImage.ExifMap = ExifMap\n\n  // Adds the following properties to the parseMetaData callback data:\n  // - exif: The parsed Exif tags\n  // - exifOffsets: The parsed Exif tag offsets\n  // - exifTiffOffset: TIFF header offset (used for offset pointers)\n  // - exifLittleEndian: little endian order if true, big endian if false\n\n  // Adds the following options to the parseMetaData method:\n  // - disableExif: Disables Exif parsing when true.\n  // - disableExifOffsets: Disables storing Exif tag offsets when true.\n  // - includeExifTags: A map of Exif tags to include for parsing.\n  // - excludeExifTags: A map of Exif tags to exclude from parsing.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUMxRCxJQUFJLEtBQUssRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtDQUErQztBQUMzRCxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLDBCQUEwQjtBQUN4QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcz8yYWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgRXhpZiBQYXJzZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIERhdGFWaWV3ICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtbWV0YSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIC8qKlxuICAgKiBFeGlmIHRhZyBtYXBcbiAgICpcbiAgICogQG5hbWUgRXhpZk1hcFxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB0YWdDb2RlIElGRCB0YWcgY29kZVxuICAgKi9cbiAgZnVuY3Rpb24gRXhpZk1hcCh0YWdDb2RlKSB7XG4gICAgaWYgKHRhZ0NvZGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWFwJywge1xuICAgICAgICB2YWx1ZTogdGhpcy5pZmRzW3RhZ0NvZGVdLm1hcFxuICAgICAgfSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGFncycsIHtcbiAgICAgICAgdmFsdWU6ICh0aGlzLnRhZ3MgJiYgdGhpcy50YWdzW3RhZ0NvZGVdKSB8fCB7fVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBFeGlmTWFwLnByb3RvdHlwZS5tYXAgPSB7XG4gICAgT3JpZW50YXRpb246IDB4MDExMixcbiAgICBUaHVtYm5haWw6ICdpZmQxJyxcbiAgICBCbG9iOiAweDAyMDEsIC8vIEFsaWFzIGZvciBKUEVHSW50ZXJjaGFuZ2VGb3JtYXRcbiAgICBFeGlmOiAweDg3NjksXG4gICAgR1BTSW5mbzogMHg4ODI1LFxuICAgIEludGVyb3BlcmFiaWxpdHk6IDB4YTAwNVxuICB9XG5cbiAgRXhpZk1hcC5wcm90b3R5cGUuaWZkcyA9IHtcbiAgICBpZmQxOiB7IG5hbWU6ICdUaHVtYm5haWwnLCBtYXA6IEV4aWZNYXAucHJvdG90eXBlLm1hcCB9LFxuICAgIDB4ODc2OTogeyBuYW1lOiAnRXhpZicsIG1hcDoge30gfSxcbiAgICAweDg4MjU6IHsgbmFtZTogJ0dQU0luZm8nLCBtYXA6IHt9IH0sXG4gICAgMHhhMDA1OiB7IG5hbWU6ICdJbnRlcm9wZXJhYmlsaXR5JywgbWFwOiB7fSB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGV4aWYgdGFnIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWQgRXhpZiB0YWcgY29kZSBvciBuYW1lXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEV4aWYgdGFnIHZhbHVlXG4gICAqL1xuICBFeGlmTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gdGhpc1tpZF0gfHwgdGhpc1t0aGlzLm1hcFtpZF1dXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRXhpZiBUaHVtYm5haWwgZGF0YSBhcyBCbG9iLlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBEYXRhIHZpZXcgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGh1bWJuYWlsIGRhdGEgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGh1bWJuYWlsIGRhdGEgbGVuZ3RoXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR8QmxvYn0gUmV0dXJucyB0aGUgVGh1bWJuYWlsIEJsb2Igb3IgdW5kZWZpbmVkXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFeGlmVGh1bWJuYWlsKGRhdGFWaWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGlmICghbGVuZ3RoKSByZXR1cm5cbiAgICBpZiAob2Zmc2V0ICsgbGVuZ3RoID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIHRodW1ibmFpbCBkYXRhLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFxuICAgICAgW2xvYWRJbWFnZS5idWZmZXJTbGljZS5jYWxsKGRhdGFWaWV3LmJ1ZmZlciwgb2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpXSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlL2pwZWcnXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgdmFyIEV4aWZUYWdUeXBlcyA9IHtcbiAgICAvLyBieXRlLCA4LWJpdCB1bnNpZ25lZCBpbnQ6XG4gICAgMToge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCkge1xuICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgoZGF0YU9mZnNldClcbiAgICAgIH0sXG4gICAgICBzaXplOiAxXG4gICAgfSxcbiAgICAvLyBhc2NpaSwgOC1iaXQgYnl0ZTpcbiAgICAyOiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGRhdGFPZmZzZXQpKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDEsXG4gICAgICBhc2NpaTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gc2hvcnQsIDE2IGJpdCBpbnQ6XG4gICAgMzoge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYoZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDJcbiAgICB9LFxuICAgIC8vIGxvbmcsIDMyIGJpdCBpbnQ6XG4gICAgNDoge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIoZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDRcbiAgICB9LFxuICAgIC8vIHJhdGlvbmFsID0gdHdvIGxvbmcgdmFsdWVzLCBmaXJzdCBpcyBudW1lcmF0b3IsIHNlY29uZCBpcyBkZW5vbWluYXRvcjpcbiAgICA1OiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRhVmlldy5nZXRVaW50MzIoZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSAvXG4gICAgICAgICAgZGF0YVZpZXcuZ2V0VWludDMyKGRhdGFPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBzaXplOiA4XG4gICAgfSxcbiAgICAvLyBzbG9uZywgMzIgYml0IHNpZ25lZCBpbnQ6XG4gICAgOToge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQzMihkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gICAgICB9LFxuICAgICAgc2l6ZTogNFxuICAgIH0sXG4gICAgLy8gc3JhdGlvbmFsLCB0d28gc2xvbmdzLCBmaXJzdCBpcyBudW1lcmF0b3IsIHNlY29uZCBpcyBkZW5vbWluYXRvcjpcbiAgICAxMDoge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZGF0YVZpZXcuZ2V0SW50MzIoZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSAvXG4gICAgICAgICAgZGF0YVZpZXcuZ2V0SW50MzIoZGF0YU9mZnNldCArIDQsIGxpdHRsZUVuZGlhbilcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDhcbiAgICB9XG4gIH1cbiAgLy8gdW5kZWZpbmVkLCA4LWJpdCBieXRlLCB2YWx1ZSBkZXBlbmRpbmcgb24gZmllbGQ6XG4gIEV4aWZUYWdUeXBlc1s3XSA9IEV4aWZUYWdUeXBlc1sxXVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIEV4aWYgdGFnIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBEYXRhIHZpZXcgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWZmT2Zmc2V0IFRJRkYgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGFnIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUYWcgdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRhZyBsZW5ndGhcbiAgICogQHBhcmFtIHtib29sZWFufSBsaXR0bGVFbmRpYW4gTGl0dGxlIGVuZGlhbiBlbmNvZGluZ1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUYWcgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIGdldEV4aWZWYWx1ZShcbiAgICBkYXRhVmlldyxcbiAgICB0aWZmT2Zmc2V0LFxuICAgIG9mZnNldCxcbiAgICB0eXBlLFxuICAgIGxlbmd0aCxcbiAgICBsaXR0bGVFbmRpYW5cbiAgKSB7XG4gICAgdmFyIHRhZ1R5cGUgPSBFeGlmVGFnVHlwZXNbdHlwZV1cbiAgICB2YXIgdGFnU2l6ZVxuICAgIHZhciBkYXRhT2Zmc2V0XG4gICAgdmFyIHZhbHVlc1xuICAgIHZhciBpXG4gICAgdmFyIHN0clxuICAgIHZhciBjXG4gICAgaWYgKCF0YWdUeXBlKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgdGFnIHR5cGUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0YWdTaXplID0gdGFnVHlwZS5zaXplICogbGVuZ3RoXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBpcyBjb250YWluZWQgaW4gdGhlIGRhdGFPZmZzZXQgYnl0ZXMsXG4gICAgLy8gb3IgaWYgdGhlIHZhbHVlIGF0IHRoZSBkYXRhT2Zmc2V0IGlzIGEgcG9pbnRlciB0byB0aGUgYWN0dWFsIGRhdGE6XG4gICAgZGF0YU9mZnNldCA9XG4gICAgICB0YWdTaXplID4gNFxuICAgICAgICA/IHRpZmZPZmZzZXQgKyBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgOCwgbGl0dGxlRW5kaWFuKVxuICAgICAgICA6IG9mZnNldCArIDhcbiAgICBpZiAoZGF0YU9mZnNldCArIHRhZ1NpemUgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgZGF0YSBvZmZzZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGFnVHlwZS5nZXRWYWx1ZShkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICAgIH1cbiAgICB2YWx1ZXMgPSBbXVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFsdWVzW2ldID0gdGFnVHlwZS5nZXRWYWx1ZShcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIGRhdGFPZmZzZXQgKyBpICogdGFnVHlwZS5zaXplLFxuICAgICAgICBsaXR0bGVFbmRpYW5cbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhZ1R5cGUuYXNjaWkpIHtcbiAgICAgIHN0ciA9ICcnXG4gICAgICAvLyBDb25jYXRlbmF0ZSB0aGUgY2hhcnM6XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGMgPSB2YWx1ZXNbaV1cbiAgICAgICAgLy8gSWdub3JlIHRoZSB0ZXJtaW5hdGluZyBOVUxMIGJ5dGUocyk6XG4gICAgICAgIGlmIChjID09PSAnXFx1MDAwMCcpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBjXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB0YWcgc2hvdWxkIGJlIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5jbHVkZVRhZ3MgTWFwIG9mIHRhZ3MgdG8gaW5jbHVkZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZXhjbHVkZVRhZ3MgTWFwIG9mIHRhZ3MgdG8gZXhjbHVkZVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHRhZ0NvZGUgVGFnIGNvZGUgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRhZyBzaG91bGQgYmUgaW5jbHVkZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZEluY2x1ZGVUYWcoaW5jbHVkZVRhZ3MsIGV4Y2x1ZGVUYWdzLCB0YWdDb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICghaW5jbHVkZVRhZ3MgfHwgaW5jbHVkZVRhZ3NbdGFnQ29kZV0pICYmXG4gICAgICAoIWV4Y2x1ZGVUYWdzIHx8IGV4Y2x1ZGVUYWdzW3RhZ0NvZGVdICE9PSB0cnVlKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgRXhpZiB0YWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBEYXRhIHZpZXcgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWZmT2Zmc2V0IFRJRkYgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJPZmZzZXQgRGlyZWN0b3J5IG9mZnNldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBMaXR0bGUgZW5kaWFuIGVuY29kaW5nXG4gICAqIEBwYXJhbSB7RXhpZk1hcH0gdGFncyBNYXAgdG8gc3RvcmUgcGFyc2VkIGV4aWYgdGFnc1xuICAgKiBAcGFyYW0ge0V4aWZNYXB9IHRhZ09mZnNldHMgTWFwIHRvIHN0b3JlIHBhcnNlZCBleGlmIHRhZyBvZmZzZXRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNsdWRlVGFncyBNYXAgb2YgdGFncyB0byBpbmNsdWRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBleGNsdWRlVGFncyBNYXAgb2YgdGFncyB0byBleGNsdWRlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IE5leHQgZGlyZWN0b3J5IG9mZnNldFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VFeGlmVGFncyhcbiAgICBkYXRhVmlldyxcbiAgICB0aWZmT2Zmc2V0LFxuICAgIGRpck9mZnNldCxcbiAgICBsaXR0bGVFbmRpYW4sXG4gICAgdGFncyxcbiAgICB0YWdPZmZzZXRzLFxuICAgIGluY2x1ZGVUYWdzLFxuICAgIGV4Y2x1ZGVUYWdzXG4gICkge1xuICAgIHZhciB0YWdzTnVtYmVyLCBkaXJFbmRPZmZzZXQsIGksIHRhZ09mZnNldCwgdGFnTnVtYmVyLCB0YWdWYWx1ZVxuICAgIGlmIChkaXJPZmZzZXQgKyA2ID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGRpcmVjdG9yeSBvZmZzZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0YWdzTnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDE2KGRpck9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICAgIGRpckVuZE9mZnNldCA9IGRpck9mZnNldCArIDIgKyAxMiAqIHRhZ3NOdW1iZXJcbiAgICBpZiAoZGlyRW5kT2Zmc2V0ICsgNCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBkaXJlY3Rvcnkgc2l6ZS4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0YWdzTnVtYmVyOyBpICs9IDEpIHtcbiAgICAgIHRhZ09mZnNldCA9IGRpck9mZnNldCArIDIgKyAxMiAqIGlcbiAgICAgIHRhZ051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNih0YWdPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICAgIGlmICghc2hvdWxkSW5jbHVkZVRhZyhpbmNsdWRlVGFncywgZXhjbHVkZVRhZ3MsIHRhZ051bWJlcikpIGNvbnRpbnVlXG4gICAgICB0YWdWYWx1ZSA9IGdldEV4aWZWYWx1ZShcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIHRpZmZPZmZzZXQsXG4gICAgICAgIHRhZ09mZnNldCxcbiAgICAgICAgZGF0YVZpZXcuZ2V0VWludDE2KHRhZ09mZnNldCArIDIsIGxpdHRsZUVuZGlhbiksIC8vIHRhZyB0eXBlXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQzMih0YWdPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pLCAvLyB0YWcgbGVuZ3RoXG4gICAgICAgIGxpdHRsZUVuZGlhblxuICAgICAgKVxuICAgICAgdGFnc1t0YWdOdW1iZXJdID0gdGFnVmFsdWVcbiAgICAgIGlmICh0YWdPZmZzZXRzKSB7XG4gICAgICAgIHRhZ09mZnNldHNbdGFnTnVtYmVyXSA9IHRhZ09mZnNldFxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIG9mZnNldCB0byB0aGUgbmV4dCBkaXJlY3Rvcnk6XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihkaXJFbmRPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGFncyBpbiBhIGdpdmVuIElGRCAoSW1hZ2UgRmlsZSBEaXJlY3RvcnkpLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBEYXRhIG9iamVjdCB0byBzdG9yZSBleGlmIHRhZ3MgYW5kIG9mZnNldHNcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB0YWdDb2RlIElGRCB0YWcgY29kZVxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBEYXRhIHZpZXcgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWZmT2Zmc2V0IFRJRkYgb2Zmc2V0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIExpdHRsZSBlbmRpYW4gZW5jb2RpbmdcbiAgICogQHBhcmFtIHtvYmplY3R9IGluY2x1ZGVUYWdzIE1hcCBvZiB0YWdzIHRvIGluY2x1ZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGV4Y2x1ZGVUYWdzIE1hcCBvZiB0YWdzIHRvIGV4Y2x1ZGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlRXhpZklGRChcbiAgICBkYXRhLFxuICAgIHRhZ0NvZGUsXG4gICAgZGF0YVZpZXcsXG4gICAgdGlmZk9mZnNldCxcbiAgICBsaXR0bGVFbmRpYW4sXG4gICAgaW5jbHVkZVRhZ3MsXG4gICAgZXhjbHVkZVRhZ3NcbiAgKSB7XG4gICAgdmFyIGRpck9mZnNldCA9IGRhdGEuZXhpZlt0YWdDb2RlXVxuICAgIGlmIChkaXJPZmZzZXQpIHtcbiAgICAgIGRhdGEuZXhpZlt0YWdDb2RlXSA9IG5ldyBFeGlmTWFwKHRhZ0NvZGUpXG4gICAgICBpZiAoZGF0YS5leGlmT2Zmc2V0cykge1xuICAgICAgICBkYXRhLmV4aWZPZmZzZXRzW3RhZ0NvZGVdID0gbmV3IEV4aWZNYXAodGFnQ29kZSlcbiAgICAgIH1cbiAgICAgIHBhcnNlRXhpZlRhZ3MoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICB0aWZmT2Zmc2V0LFxuICAgICAgICB0aWZmT2Zmc2V0ICsgZGlyT2Zmc2V0LFxuICAgICAgICBsaXR0bGVFbmRpYW4sXG4gICAgICAgIGRhdGEuZXhpZlt0YWdDb2RlXSxcbiAgICAgICAgZGF0YS5leGlmT2Zmc2V0cyAmJiBkYXRhLmV4aWZPZmZzZXRzW3RhZ0NvZGVdLFxuICAgICAgICBpbmNsdWRlVGFncyAmJiBpbmNsdWRlVGFnc1t0YWdDb2RlXSxcbiAgICAgICAgZXhjbHVkZVRhZ3MgJiYgZXhjbHVkZVRhZ3NbdGFnQ29kZV1cbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBsb2FkSW1hZ2UucGFyc2VFeGlmRGF0YSA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlRXhpZikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpbmNsdWRlVGFncyA9IG9wdGlvbnMuaW5jbHVkZUV4aWZUYWdzXG4gICAgdmFyIGV4Y2x1ZGVUYWdzID0gb3B0aW9ucy5leGNsdWRlRXhpZlRhZ3MgfHwge1xuICAgICAgMHg4NzY5OiB7XG4gICAgICAgIC8vIEV4aWZJRkRQb2ludGVyXG4gICAgICAgIDB4OTI3YzogdHJ1ZSAvLyBNYWtlck5vdGVcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRpZmZPZmZzZXQgPSBvZmZzZXQgKyAxMFxuICAgIHZhciBsaXR0bGVFbmRpYW5cbiAgICB2YXIgZGlyT2Zmc2V0XG4gICAgdmFyIHRodW1ibmFpbElGRFxuICAgIC8vIENoZWNrIGZvciB0aGUgQVNDSUkgY29kZSBmb3IgXCJFeGlmXCIgKDB4NDU3ODY5NjYpOlxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCkgIT09IDB4NDU3ODY5NjYpIHtcbiAgICAgIC8vIE5vIEV4aWYgZGF0YSwgbWlnaHQgYmUgWE1QIGRhdGEgaW5zdGVhZFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aWZmT2Zmc2V0ICsgOCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBzZWdtZW50IHNpemUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgdGhlIHR3byBudWxsIGJ5dGVzOlxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgOCkgIT09IDB4MDAwMCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBNaXNzaW5nIGJ5dGUgYWxpZ25tZW50IG9mZnNldC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIENoZWNrIHRoZSBieXRlIGFsaWdubWVudDpcbiAgICBzd2l0Y2ggKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSkge1xuICAgICAgY2FzZSAweDQ5NDk6XG4gICAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMHg0ZDRkOlxuICAgICAgICBsaXR0bGVFbmRpYW4gPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGJ5dGUgYWxpZ25tZW50IG1hcmtlci4nKVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBUSUZGIHRhZyBtYXJrZXIgKDB4MDAyQSk6XG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSAhPT0gMHgwMDJhKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IE1pc3NpbmcgVElGRiBtYXJrZXIuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBSZXRyaWV2ZSB0aGUgZGlyZWN0b3J5IG9mZnNldCBieXRlcywgdXN1YWxseSAweDAwMDAwMDA4IG9yIDggZGVjaW1hbDpcbiAgICBkaXJPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsIGxpdHRsZUVuZGlhbilcbiAgICAvLyBDcmVhdGUgdGhlIGV4aWYgb2JqZWN0IHRvIHN0b3JlIHRoZSB0YWdzOlxuICAgIGRhdGEuZXhpZiA9IG5ldyBFeGlmTWFwKClcbiAgICBpZiAoIW9wdGlvbnMuZGlzYWJsZUV4aWZPZmZzZXRzKSB7XG4gICAgICBkYXRhLmV4aWZPZmZzZXRzID0gbmV3IEV4aWZNYXAoKVxuICAgICAgZGF0YS5leGlmVGlmZk9mZnNldCA9IHRpZmZPZmZzZXRcbiAgICAgIGRhdGEuZXhpZkxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhblxuICAgIH1cbiAgICAvLyBQYXJzZSB0aGUgdGFncyBvZiB0aGUgbWFpbiBpbWFnZSBkaXJlY3RvcnkgKElGRDApIGFuZCByZXRyaWV2ZSB0aGVcbiAgICAvLyBvZmZzZXQgdG8gdGhlIG5leHQgZGlyZWN0b3J5IChJRkQxKSwgdXN1YWxseSB0aGUgdGh1bWJuYWlsIGRpcmVjdG9yeTpcbiAgICBkaXJPZmZzZXQgPSBwYXJzZUV4aWZUYWdzKFxuICAgICAgZGF0YVZpZXcsXG4gICAgICB0aWZmT2Zmc2V0LFxuICAgICAgdGlmZk9mZnNldCArIGRpck9mZnNldCxcbiAgICAgIGxpdHRsZUVuZGlhbixcbiAgICAgIGRhdGEuZXhpZixcbiAgICAgIGRhdGEuZXhpZk9mZnNldHMsXG4gICAgICBpbmNsdWRlVGFncyxcbiAgICAgIGV4Y2x1ZGVUYWdzXG4gICAgKVxuICAgIGlmIChkaXJPZmZzZXQgJiYgc2hvdWxkSW5jbHVkZVRhZyhpbmNsdWRlVGFncywgZXhjbHVkZVRhZ3MsICdpZmQxJykpIHtcbiAgICAgIGRhdGEuZXhpZi5pZmQxID0gZGlyT2Zmc2V0XG4gICAgICBpZiAoZGF0YS5leGlmT2Zmc2V0cykge1xuICAgICAgICBkYXRhLmV4aWZPZmZzZXRzLmlmZDEgPSB0aWZmT2Zmc2V0ICsgZGlyT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGRhdGEuZXhpZi5pZmRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWdDb2RlKSB7XG4gICAgICBwYXJzZUV4aWZJRkQoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHRhZ0NvZGUsXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICB0aWZmT2Zmc2V0LFxuICAgICAgICBsaXR0bGVFbmRpYW4sXG4gICAgICAgIGluY2x1ZGVUYWdzLFxuICAgICAgICBleGNsdWRlVGFnc1xuICAgICAgKVxuICAgIH0pXG4gICAgdGh1bWJuYWlsSUZEID0gZGF0YS5leGlmLmlmZDFcbiAgICAvLyBDaGVjayBmb3IgSlBFRyBUaHVtYm5haWwgb2Zmc2V0IGFuZCBkYXRhIGxlbmd0aDpcbiAgICBpZiAodGh1bWJuYWlsSUZEICYmIHRodW1ibmFpbElGRFsweDAyMDFdKSB7XG4gICAgICB0aHVtYm5haWxJRkRbMHgwMjAxXSA9IGdldEV4aWZUaHVtYm5haWwoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICB0aWZmT2Zmc2V0ICsgdGh1bWJuYWlsSUZEWzB4MDIwMV0sXG4gICAgICAgIHRodW1ibmFpbElGRFsweDAyMDJdIC8vIFRodW1ibmFpbCBkYXRhIGxlbmd0aFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVycyB0aGUgRXhpZiBwYXJzZXIgZm9yIHRoZSBBUFAxIEpQRUcgbWV0YWRhdGEgc2VnbWVudDpcbiAgbG9hZEltYWdlLm1ldGFEYXRhUGFyc2Vycy5qcGVnWzB4ZmZlMV0ucHVzaChsb2FkSW1hZ2UucGFyc2VFeGlmRGF0YSlcblxuICBsb2FkSW1hZ2UuZXhpZldyaXRlcnMgPSB7XG4gICAgLy8gT3JpZW50YXRpb24gd3JpdGVyOlxuICAgIDB4MDExMjogZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSwgdmFsdWUpIHtcbiAgICAgIHZhciBvcmllbnRhdGlvbk9mZnNldCA9IGRhdGEuZXhpZk9mZnNldHNbMHgwMTEyXVxuICAgICAgaWYgKCFvcmllbnRhdGlvbk9mZnNldCkgcmV0dXJuIGJ1ZmZlclxuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCBvcmllbnRhdGlvbk9mZnNldCArIDgsIDIpXG4gICAgICB2aWV3LnNldFVpbnQxNigwLCB2YWx1ZSwgZGF0YS5leGlmTGl0dGxlRW5kaWFuKVxuICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGxvYWRJbWFnZS53cml0ZUV4aWZEYXRhID0gZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSwgaWQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGxvYWRJbWFnZS5leGlmV3JpdGVyc1tkYXRhLmV4aWYubWFwW2lkXV0oYnVmZmVyLCBkYXRhLCB2YWx1ZSlcbiAgfVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwID0gRXhpZk1hcFxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBwYXJzZU1ldGFEYXRhIGNhbGxiYWNrIGRhdGE6XG4gIC8vIC0gZXhpZjogVGhlIHBhcnNlZCBFeGlmIHRhZ3NcbiAgLy8gLSBleGlmT2Zmc2V0czogVGhlIHBhcnNlZCBFeGlmIHRhZyBvZmZzZXRzXG4gIC8vIC0gZXhpZlRpZmZPZmZzZXQ6IFRJRkYgaGVhZGVyIG9mZnNldCAodXNlZCBmb3Igb2Zmc2V0IHBvaW50ZXJzKVxuICAvLyAtIGV4aWZMaXR0bGVFbmRpYW46IGxpdHRsZSBlbmRpYW4gb3JkZXIgaWYgdHJ1ZSwgYmlnIGVuZGlhbiBpZiBmYWxzZVxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBvcHRpb25zIHRvIHRoZSBwYXJzZU1ldGFEYXRhIG1ldGhvZDpcbiAgLy8gLSBkaXNhYmxlRXhpZjogRGlzYWJsZXMgRXhpZiBwYXJzaW5nIHdoZW4gdHJ1ZS5cbiAgLy8gLSBkaXNhYmxlRXhpZk9mZnNldHM6IERpc2FibGVzIHN0b3JpbmcgRXhpZiB0YWcgb2Zmc2V0cyB3aGVuIHRydWUuXG4gIC8vIC0gaW5jbHVkZUV4aWZUYWdzOiBBIG1hcCBvZiBFeGlmIHRhZ3MgdG8gaW5jbHVkZSBmb3IgcGFyc2luZy5cbiAgLy8gLSBleGNsdWRlRXhpZlRhZ3M6IEEgbWFwIG9mIEV4aWYgdGFncyB0byBleGNsdWRlIGZyb20gcGFyc2luZy5cbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-fetch.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n\n  if (\n    global.fetch &&\n    global.Request &&\n    global.Response &&\n    global.Response.prototype.blob\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      /**\n       * Fetch response handler.\n       *\n       * @param {Response} response Fetch response\n       * @returns {Blob} Fetched Blob.\n       */\n      function responseHandler(response) {\n        return response.blob()\n      }\n      if (global.Promise && typeof callback !== 'function') {\n        return fetch(new Request(url, callback)).then(responseHandler)\n      }\n      fetch(new Request(url, options))\n        .then(responseHandler)\n        .then(callback)\n        [\n          // Avoid parsing error in IE<9, where catch is a reserved word.\n          // eslint-disable-next-line dot-notation\n          'catch'\n        ](function (err) {\n          callback(null, err)\n        })\n    }\n  } else if (\n    global.XMLHttpRequest &&\n    // https://xhr.spec.whatwg.org/#the-responsetype-attribute\n    new XMLHttpRequest().responseType === ''\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      /**\n       * Promise executor\n       *\n       * @param {Function} resolve Resolution function\n       * @param {Function} reject Rejection function\n       */\n      function executor(resolve, reject) {\n        options = options || {} // eslint-disable-line no-param-reassign\n        var req = new XMLHttpRequest()\n        req.open(options.method || 'GET', url)\n        if (options.headers) {\n          Object.keys(options.headers).forEach(function (key) {\n            req.setRequestHeader(key, options.headers[key])\n          })\n        }\n        req.withCredentials = options.credentials === 'include'\n        req.responseType = 'blob'\n        req.onload = function () {\n          resolve(req.response)\n        }\n        req.onerror =\n          req.onabort =\n          req.ontimeout =\n            function (err) {\n              if (resolve === reject) {\n                // Not using Promises\n                reject(null, err)\n              } else {\n                reject(err)\n              }\n            }\n        req.send(options.body)\n      }\n      if (global.Promise && typeof callback !== 'function') {\n        options = callback // eslint-disable-line no-param-reassign\n        return new Promise(executor)\n      }\n      return executor(callback, callback)\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckMsSUFBSSxLQUFLLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQixtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWZldGNoLmpzPzliOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBGZXRjaFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTcsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSwgUHJvbWlzZSAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIGdsb2JhbCA9IGxvYWRJbWFnZS5nbG9iYWxcblxuICBpZiAoXG4gICAgZ2xvYmFsLmZldGNoICYmXG4gICAgZ2xvYmFsLlJlcXVlc3QgJiZcbiAgICBnbG9iYWwuUmVzcG9uc2UgJiZcbiAgICBnbG9iYWwuUmVzcG9uc2UucHJvdG90eXBlLmJsb2JcbiAgKSB7XG4gICAgbG9hZEltYWdlLmZldGNoQmxvYiA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZldGNoIHJlc3BvbnNlIGhhbmRsZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgRmV0Y2ggcmVzcG9uc2VcbiAgICAgICAqIEByZXR1cm5zIHtCbG9ifSBGZXRjaGVkIEJsb2IuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpXG4gICAgICB9XG4gICAgICBpZiAoZ2xvYmFsLlByb21pc2UgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmZXRjaChuZXcgUmVxdWVzdCh1cmwsIGNhbGxiYWNrKSkudGhlbihyZXNwb25zZUhhbmRsZXIpXG4gICAgICB9XG4gICAgICBmZXRjaChuZXcgUmVxdWVzdCh1cmwsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbihyZXNwb25zZUhhbmRsZXIpXG4gICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICBbXG4gICAgICAgICAgLy8gQXZvaWQgcGFyc2luZyBlcnJvciBpbiBJRTw5LCB3aGVyZSBjYXRjaCBpcyBhIHJlc2VydmVkIHdvcmQuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICAgICdjYXRjaCdcbiAgICAgICAgXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZXJyKVxuICAgICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwuWE1MSHR0cFJlcXVlc3QgJiZcbiAgICAvLyBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3RoZS1yZXNwb25zZXR5cGUtYXR0cmlidXRlXG4gICAgbmV3IFhNTEh0dHBSZXF1ZXN0KCkucmVzcG9uc2VUeXBlID09PSAnJ1xuICApIHtcbiAgICBsb2FkSW1hZ2UuZmV0Y2hCbG9iID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJvbWlzZSBleGVjdXRvclxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgUmVzb2x1dGlvbiBmdW5jdGlvblxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IFJlamVjdGlvbiBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgcmVxLm9wZW4ob3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsIHVybClcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdGlvbnMuaGVhZGVyc1trZXldKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJ1xuICAgICAgICByZXEucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXEucmVzcG9uc2UpXG4gICAgICAgIH1cbiAgICAgICAgcmVxLm9uZXJyb3IgPVxuICAgICAgICAgIHJlcS5vbmFib3J0ID1cbiAgICAgICAgICByZXEub250aW1lb3V0ID1cbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc29sdmUgPT09IHJlamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCB1c2luZyBQcm9taXNlc1xuICAgICAgICAgICAgICAgIHJlamVjdChudWxsLCBlcnIpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXEuc2VuZChvcHRpb25zLmJvZHkpXG4gICAgICB9XG4gICAgICBpZiAoZ2xvYmFsLlByb21pc2UgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjYWxsYmFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShleGVjdXRvcilcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRvcihjYWxsYmFjaywgY2FsbGJhY2spXG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-fetch.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc-map.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://iptc.org/standards/photo-metadata\n * https://exiftool.org/TagNames/IPTC.html\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var IptcMapProto = loadImage.IptcMap.prototype\n\n  IptcMapProto.tags = {\n    0: 'ApplicationRecordVersion',\n    3: 'ObjectTypeReference',\n    4: 'ObjectAttributeReference',\n    5: 'ObjectName',\n    7: 'EditStatus',\n    8: 'EditorialUpdate',\n    10: 'Urgency',\n    12: 'SubjectReference',\n    15: 'Category',\n    20: 'SupplementalCategories',\n    22: 'FixtureIdentifier',\n    25: 'Keywords',\n    26: 'ContentLocationCode',\n    27: 'ContentLocationName',\n    30: 'ReleaseDate',\n    35: 'ReleaseTime',\n    37: 'ExpirationDate',\n    38: 'ExpirationTime',\n    40: 'SpecialInstructions',\n    42: 'ActionAdvised',\n    45: 'ReferenceService',\n    47: 'ReferenceDate',\n    50: 'ReferenceNumber',\n    55: 'DateCreated',\n    60: 'TimeCreated',\n    62: 'DigitalCreationDate',\n    63: 'DigitalCreationTime',\n    65: 'OriginatingProgram',\n    70: 'ProgramVersion',\n    75: 'ObjectCycle',\n    80: 'Byline',\n    85: 'BylineTitle',\n    90: 'City',\n    92: 'Sublocation',\n    95: 'State',\n    100: 'CountryCode',\n    101: 'Country',\n    103: 'OriginalTransmissionReference',\n    105: 'Headline',\n    110: 'Credit',\n    115: 'Source',\n    116: 'CopyrightNotice',\n    118: 'Contact',\n    120: 'Caption',\n    121: 'LocalCaption',\n    122: 'Writer',\n    125: 'RasterizedCaption',\n    130: 'ImageType',\n    131: 'ImageOrientation',\n    135: 'LanguageIdentifier',\n    150: 'AudioType',\n    151: 'AudioSamplingRate',\n    152: 'AudioSamplingResolution',\n    153: 'AudioDuration',\n    154: 'AudioOutcue',\n    184: 'JobID',\n    185: 'MasterDocumentID',\n    186: 'ShortDocumentID',\n    187: 'UniqueDocumentID',\n    188: 'OwnerID',\n    200: 'ObjectPreviewFileFormat',\n    201: 'ObjectPreviewFileVersion',\n    202: 'ObjectPreviewData',\n    221: 'Prefs',\n    225: 'ClassifyState',\n    228: 'SimilarityIndex',\n    230: 'DocumentNotes',\n    231: 'DocumentHistory',\n    232: 'ExifCameraInfo',\n    255: 'CatalogSets'\n  }\n\n  IptcMapProto.stringValues = {\n    10: {\n      0: '0 (reserved)',\n      1: '1 (most urgent)',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5 (normal urgency)',\n      6: '6',\n      7: '7',\n      8: '8 (least urgent)',\n      9: '9 (user-defined priority)'\n    },\n    75: {\n      a: 'Morning',\n      b: 'Both Morning and Evening',\n      p: 'Evening'\n    },\n    131: {\n      L: 'Landscape',\n      P: 'Portrait',\n      S: 'Square'\n    }\n  }\n\n  IptcMapProto.getText = function (id) {\n    var value = this.get(id)\n    var tagCode = this.map[id]\n    var stringValue = this.stringValues[tagCode]\n    if (stringValue) return stringValue[value]\n    return String(value)\n  }\n\n  IptcMapProto.getAll = function () {\n    var map = {}\n    var prop\n    var name\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        name = this.tags[prop]\n        if (name) map[name] = this.getText(name)\n      }\n    }\n    return map\n  }\n\n  IptcMapProto.getName = function (tagCode) {\n    return this.tags[tagCode]\n  }\n\n  // Extend the map of tag names to tag codes:\n  ;(function () {\n    var tags = IptcMapProto.tags\n    var map = IptcMapProto.map || {}\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = Number(prop)\n      }\n    }\n  })()\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUMxRCxJQUFJLEtBQUssRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1pcHRjLW1hcC5qcz81NjMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgSVBUQyBNYXBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBDb3B5cmlnaHQgMjAxOCwgRGF2ZSBCZXZhblxuICpcbiAqIElQVEMgdGFncyBtYXBwaW5nIGJhc2VkIG9uXG4gKiBodHRwczovL2lwdGMub3JnL3N0YW5kYXJkcy9waG90by1tZXRhZGF0YVxuICogaHR0cHM6Ly9leGlmdG9vbC5vcmcvVGFnTmFtZXMvSVBUQy5odG1sXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtaXB0YyddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLWlwdGMnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBJcHRjTWFwUHJvdG8gPSBsb2FkSW1hZ2UuSXB0Y01hcC5wcm90b3R5cGVcblxuICBJcHRjTWFwUHJvdG8udGFncyA9IHtcbiAgICAwOiAnQXBwbGljYXRpb25SZWNvcmRWZXJzaW9uJyxcbiAgICAzOiAnT2JqZWN0VHlwZVJlZmVyZW5jZScsXG4gICAgNDogJ09iamVjdEF0dHJpYnV0ZVJlZmVyZW5jZScsXG4gICAgNTogJ09iamVjdE5hbWUnLFxuICAgIDc6ICdFZGl0U3RhdHVzJyxcbiAgICA4OiAnRWRpdG9yaWFsVXBkYXRlJyxcbiAgICAxMDogJ1VyZ2VuY3knLFxuICAgIDEyOiAnU3ViamVjdFJlZmVyZW5jZScsXG4gICAgMTU6ICdDYXRlZ29yeScsXG4gICAgMjA6ICdTdXBwbGVtZW50YWxDYXRlZ29yaWVzJyxcbiAgICAyMjogJ0ZpeHR1cmVJZGVudGlmaWVyJyxcbiAgICAyNTogJ0tleXdvcmRzJyxcbiAgICAyNjogJ0NvbnRlbnRMb2NhdGlvbkNvZGUnLFxuICAgIDI3OiAnQ29udGVudExvY2F0aW9uTmFtZScsXG4gICAgMzA6ICdSZWxlYXNlRGF0ZScsXG4gICAgMzU6ICdSZWxlYXNlVGltZScsXG4gICAgMzc6ICdFeHBpcmF0aW9uRGF0ZScsXG4gICAgMzg6ICdFeHBpcmF0aW9uVGltZScsXG4gICAgNDA6ICdTcGVjaWFsSW5zdHJ1Y3Rpb25zJyxcbiAgICA0MjogJ0FjdGlvbkFkdmlzZWQnLFxuICAgIDQ1OiAnUmVmZXJlbmNlU2VydmljZScsXG4gICAgNDc6ICdSZWZlcmVuY2VEYXRlJyxcbiAgICA1MDogJ1JlZmVyZW5jZU51bWJlcicsXG4gICAgNTU6ICdEYXRlQ3JlYXRlZCcsXG4gICAgNjA6ICdUaW1lQ3JlYXRlZCcsXG4gICAgNjI6ICdEaWdpdGFsQ3JlYXRpb25EYXRlJyxcbiAgICA2MzogJ0RpZ2l0YWxDcmVhdGlvblRpbWUnLFxuICAgIDY1OiAnT3JpZ2luYXRpbmdQcm9ncmFtJyxcbiAgICA3MDogJ1Byb2dyYW1WZXJzaW9uJyxcbiAgICA3NTogJ09iamVjdEN5Y2xlJyxcbiAgICA4MDogJ0J5bGluZScsXG4gICAgODU6ICdCeWxpbmVUaXRsZScsXG4gICAgOTA6ICdDaXR5JyxcbiAgICA5MjogJ1N1YmxvY2F0aW9uJyxcbiAgICA5NTogJ1N0YXRlJyxcbiAgICAxMDA6ICdDb3VudHJ5Q29kZScsXG4gICAgMTAxOiAnQ291bnRyeScsXG4gICAgMTAzOiAnT3JpZ2luYWxUcmFuc21pc3Npb25SZWZlcmVuY2UnLFxuICAgIDEwNTogJ0hlYWRsaW5lJyxcbiAgICAxMTA6ICdDcmVkaXQnLFxuICAgIDExNTogJ1NvdXJjZScsXG4gICAgMTE2OiAnQ29weXJpZ2h0Tm90aWNlJyxcbiAgICAxMTg6ICdDb250YWN0JyxcbiAgICAxMjA6ICdDYXB0aW9uJyxcbiAgICAxMjE6ICdMb2NhbENhcHRpb24nLFxuICAgIDEyMjogJ1dyaXRlcicsXG4gICAgMTI1OiAnUmFzdGVyaXplZENhcHRpb24nLFxuICAgIDEzMDogJ0ltYWdlVHlwZScsXG4gICAgMTMxOiAnSW1hZ2VPcmllbnRhdGlvbicsXG4gICAgMTM1OiAnTGFuZ3VhZ2VJZGVudGlmaWVyJyxcbiAgICAxNTA6ICdBdWRpb1R5cGUnLFxuICAgIDE1MTogJ0F1ZGlvU2FtcGxpbmdSYXRlJyxcbiAgICAxNTI6ICdBdWRpb1NhbXBsaW5nUmVzb2x1dGlvbicsXG4gICAgMTUzOiAnQXVkaW9EdXJhdGlvbicsXG4gICAgMTU0OiAnQXVkaW9PdXRjdWUnLFxuICAgIDE4NDogJ0pvYklEJyxcbiAgICAxODU6ICdNYXN0ZXJEb2N1bWVudElEJyxcbiAgICAxODY6ICdTaG9ydERvY3VtZW50SUQnLFxuICAgIDE4NzogJ1VuaXF1ZURvY3VtZW50SUQnLFxuICAgIDE4ODogJ093bmVySUQnLFxuICAgIDIwMDogJ09iamVjdFByZXZpZXdGaWxlRm9ybWF0JyxcbiAgICAyMDE6ICdPYmplY3RQcmV2aWV3RmlsZVZlcnNpb24nLFxuICAgIDIwMjogJ09iamVjdFByZXZpZXdEYXRhJyxcbiAgICAyMjE6ICdQcmVmcycsXG4gICAgMjI1OiAnQ2xhc3NpZnlTdGF0ZScsXG4gICAgMjI4OiAnU2ltaWxhcml0eUluZGV4JyxcbiAgICAyMzA6ICdEb2N1bWVudE5vdGVzJyxcbiAgICAyMzE6ICdEb2N1bWVudEhpc3RvcnknLFxuICAgIDIzMjogJ0V4aWZDYW1lcmFJbmZvJyxcbiAgICAyNTU6ICdDYXRhbG9nU2V0cydcbiAgfVxuXG4gIElwdGNNYXBQcm90by5zdHJpbmdWYWx1ZXMgPSB7XG4gICAgMTA6IHtcbiAgICAgIDA6ICcwIChyZXNlcnZlZCknLFxuICAgICAgMTogJzEgKG1vc3QgdXJnZW50KScsXG4gICAgICAyOiAnMicsXG4gICAgICAzOiAnMycsXG4gICAgICA0OiAnNCcsXG4gICAgICA1OiAnNSAobm9ybWFsIHVyZ2VuY3kpJyxcbiAgICAgIDY6ICc2JyxcbiAgICAgIDc6ICc3JyxcbiAgICAgIDg6ICc4IChsZWFzdCB1cmdlbnQpJyxcbiAgICAgIDk6ICc5ICh1c2VyLWRlZmluZWQgcHJpb3JpdHkpJ1xuICAgIH0sXG4gICAgNzU6IHtcbiAgICAgIGE6ICdNb3JuaW5nJyxcbiAgICAgIGI6ICdCb3RoIE1vcm5pbmcgYW5kIEV2ZW5pbmcnLFxuICAgICAgcDogJ0V2ZW5pbmcnXG4gICAgfSxcbiAgICAxMzE6IHtcbiAgICAgIEw6ICdMYW5kc2NhcGUnLFxuICAgICAgUDogJ1BvcnRyYWl0JyxcbiAgICAgIFM6ICdTcXVhcmUnXG4gICAgfVxuICB9XG5cbiAgSXB0Y01hcFByb3RvLmdldFRleHQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChpZClcbiAgICB2YXIgdGFnQ29kZSA9IHRoaXMubWFwW2lkXVxuICAgIHZhciBzdHJpbmdWYWx1ZSA9IHRoaXMuc3RyaW5nVmFsdWVzW3RhZ0NvZGVdXG4gICAgaWYgKHN0cmluZ1ZhbHVlKSByZXR1cm4gc3RyaW5nVmFsdWVbdmFsdWVdXG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgfVxuXG4gIElwdGNNYXBQcm90by5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IHt9XG4gICAgdmFyIHByb3BcbiAgICB2YXIgbmFtZVxuICAgIGZvciAocHJvcCBpbiB0aGlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3ApKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnRhZ3NbcHJvcF1cbiAgICAgICAgaWYgKG5hbWUpIG1hcFtuYW1lXSA9IHRoaXMuZ2V0VGV4dChuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICBJcHRjTWFwUHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uICh0YWdDb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnc1t0YWdDb2RlXVxuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBtYXAgb2YgdGFnIG5hbWVzIHRvIHRhZyBjb2RlczpcbiAgOyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRhZ3MgPSBJcHRjTWFwUHJvdG8udGFnc1xuICAgIHZhciBtYXAgPSBJcHRjTWFwUHJvdG8ubWFwIHx8IHt9XG4gICAgdmFyIHByb3BcbiAgICAvLyBNYXAgdGhlIHRhZyBuYW1lcyB0byB0YWdzOlxuICAgIGZvciAocHJvcCBpbiB0YWdzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhZ3MsIHByb3ApKSB7XG4gICAgICAgIG1hcFt0YWdzW3Byb3BdXSA9IE51bWJlcihwcm9wKVxuICAgICAgfVxuICAgIH1cbiAgfSkoKVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc-map.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  /**\n   * IPTC tag map\n   *\n   * @name IptcMap\n   * @class\n   */\n  function IptcMap() {}\n\n  IptcMap.prototype.map = {\n    ObjectName: 5\n  }\n\n  IptcMap.prototype.types = {\n    0: 'Uint16', // ApplicationRecordVersion\n    200: 'Uint16', // ObjectPreviewFileFormat\n    201: 'Uint16', // ObjectPreviewFileVersion\n    202: 'binary' // ObjectPreviewData\n  }\n\n  /**\n   * Retrieves IPTC tag value\n   *\n   * @param {number|string} id IPTC tag code or name\n   * @returns {object} IPTC tag value\n   */\n  IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  /**\n   * Retrieves string for the given DataView and range\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Offset start\n   * @param {number} length Offset length\n   * @returns {string} String value\n   */\n  function getStringValue(dataView, offset, length) {\n    var outstr = ''\n    var end = offset + length\n    for (var n = offset; n < end; n += 1) {\n      outstr += String.fromCharCode(dataView.getUint8(n))\n    }\n    return outstr\n  }\n\n  /**\n   * Retrieves tag value for the given DataView and range\n   *\n   * @param {number} tagCode tag code\n   * @param {IptcMap} map IPTC tag map\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Range start\n   * @param {number} length Range length\n   * @returns {object} Tag value\n   */\n  function getTagValue(tagCode, map, dataView, offset, length) {\n    if (map.types[tagCode] === 'binary') {\n      return new Blob([dataView.buffer.slice(offset, offset + length)])\n    }\n    if (map.types[tagCode] === 'Uint16') {\n      return dataView.getUint16(offset)\n    }\n    return getStringValue(dataView, offset, length)\n  }\n\n  /**\n   * Combines IPTC value with existing ones.\n   *\n   * @param {object} value Existing IPTC field value\n   * @param {object} newValue New IPTC field value\n   * @returns {object} Resulting IPTC field value\n   */\n  function combineTagValues(value, newValue) {\n    if (value === undefined) return newValue\n    if (value instanceof Array) {\n      value.push(newValue)\n      return value\n    }\n    return [value, newValue]\n  }\n\n  /**\n   * Parses IPTC tags.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} segmentOffset Segment offset\n   * @param {number} segmentLength Segment length\n   * @param {object} data Data export object\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   */\n  function parseIptcTags(\n    dataView,\n    segmentOffset,\n    segmentLength,\n    data,\n    includeTags,\n    excludeTags\n  ) {\n    var value, tagSize, tagCode\n    var segmentEnd = segmentOffset + segmentLength\n    var offset = segmentOffset\n    while (offset < segmentEnd) {\n      if (\n        dataView.getUint8(offset) === 0x1c && // tag marker\n        dataView.getUint8(offset + 1) === 0x02 // record number, only handles v2\n      ) {\n        tagCode = dataView.getUint8(offset + 2)\n        if (\n          (!includeTags || includeTags[tagCode]) &&\n          (!excludeTags || !excludeTags[tagCode])\n        ) {\n          tagSize = dataView.getInt16(offset + 3)\n          value = getTagValue(tagCode, data.iptc, dataView, offset + 5, tagSize)\n          data.iptc[tagCode] = combineTagValues(data.iptc[tagCode], value)\n          if (data.iptcOffsets) {\n            data.iptcOffsets[tagCode] = offset\n          }\n        }\n      }\n      offset += 1\n    }\n  }\n\n  /**\n   * Tests if field segment starts at offset.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Segment offset\n   * @returns {boolean} True if '8BIM<EOT><EOT>' exists at offset\n   */\n  function isSegmentStart(dataView, offset) {\n    return (\n      dataView.getUint32(offset) === 0x3842494d && // Photoshop segment start\n      dataView.getUint16(offset + 4) === 0x0404 // IPTC segment start\n    )\n  }\n\n  /**\n   * Returns header length.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Segment offset\n   * @returns {number} Header length\n   */\n  function getHeaderLength(dataView, offset) {\n    var length = dataView.getUint8(offset + 7)\n    if (length % 2 !== 0) length += 1\n    // Check for pre photoshop 6 format\n    if (length === 0) {\n      // Always 4\n      length = 4\n    }\n    return length\n  }\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return\n    }\n    var markerLength = offset + length\n    while (offset + 8 < markerLength) {\n      if (isSegmentStart(dataView, offset)) {\n        var headerLength = getHeaderLength(dataView, offset)\n        var segmentOffset = offset + 8 + headerLength\n        if (segmentOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.')\n          break\n        }\n        var segmentLength = dataView.getUint16(offset + 6 + headerLength)\n        if (offset + segmentLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.')\n          break\n        }\n        // Create the iptc object to store the tags:\n        data.iptc = new IptcMap()\n        if (!options.disableIptcOffsets) {\n          data.iptcOffsets = new IptcMap()\n        }\n        parseIptcTags(\n          dataView,\n          segmentOffset,\n          segmentLength,\n          data,\n          options.includeIptcTags,\n          options.excludeIptcTags || { 202: true } // ObjectPreviewData\n        )\n        return\n      }\n      // eslint-disable-next-line no-param-reassign\n      offset += 1\n    }\n  }\n\n  // Registers this IPTC parser for the APP13 JPEG metadata segment:\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData)\n\n  loadImage.IptcMap = IptcMap\n\n  // Adds the following properties to the parseMetaData callback data:\n  // - iptc: The iptc tags, parsed by the parseIptcData method\n\n  // Adds the following options to the parseMetaData method:\n  // - disableIptc: Disables IPTC parsing when true.\n  // - disableIptcOffsets: Disables storing IPTC tag offsets when true.\n  // - includeIptcTags: A map of IPTC tags to include for parsing.\n  // - excludeIptcTags: A map of IPTC tags to exclude from parsing.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsRUFBRSx1R0FBbUIsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQzFELElBQUksS0FBSyxFQUtOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWlwdGMuanM/MDMwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIElQVEMgUGFyc2VyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogQ29weXJpZ2h0IDIwMTgsIERhdmUgQmV2YW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSwgRGF0YVZpZXcgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtbWV0YSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIC8qKlxuICAgKiBJUFRDIHRhZyBtYXBcbiAgICpcbiAgICogQG5hbWUgSXB0Y01hcFxuICAgKiBAY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIElwdGNNYXAoKSB7fVxuXG4gIElwdGNNYXAucHJvdG90eXBlLm1hcCA9IHtcbiAgICBPYmplY3ROYW1lOiA1XG4gIH1cblxuICBJcHRjTWFwLnByb3RvdHlwZS50eXBlcyA9IHtcbiAgICAwOiAnVWludDE2JywgLy8gQXBwbGljYXRpb25SZWNvcmRWZXJzaW9uXG4gICAgMjAwOiAnVWludDE2JywgLy8gT2JqZWN0UHJldmlld0ZpbGVGb3JtYXRcbiAgICAyMDE6ICdVaW50MTYnLCAvLyBPYmplY3RQcmV2aWV3RmlsZVZlcnNpb25cbiAgICAyMDI6ICdiaW5hcnknIC8vIE9iamVjdFByZXZpZXdEYXRhXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIElQVEMgdGFnIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWQgSVBUQyB0YWcgY29kZSBvciBuYW1lXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IElQVEMgdGFnIHZhbHVlXG4gICAqL1xuICBJcHRjTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gdGhpc1tpZF0gfHwgdGhpc1t0aGlzLm1hcFtpZF1dXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHN0cmluZyBmb3IgdGhlIGdpdmVuIERhdGFWaWV3IGFuZCByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBEYXRhIHZpZXcgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggT2Zmc2V0IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0cmluZ1ZhbHVlKGRhdGFWaWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHZhciBvdXRzdHIgPSAnJ1xuICAgIHZhciBlbmQgPSBvZmZzZXQgKyBsZW5ndGhcbiAgICBmb3IgKHZhciBuID0gb2Zmc2V0OyBuIDwgZW5kOyBuICs9IDEpIHtcbiAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG4pKVxuICAgIH1cbiAgICByZXR1cm4gb3V0c3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRhZyB2YWx1ZSBmb3IgdGhlIGdpdmVuIERhdGFWaWV3IGFuZCByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFnQ29kZSB0YWcgY29kZVxuICAgKiBAcGFyYW0ge0lwdGNNYXB9IG1hcCBJUFRDIHRhZyBtYXBcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFJhbmdlIHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggUmFuZ2UgbGVuZ3RoXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFRhZyB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGFnVmFsdWUodGFnQ29kZSwgbWFwLCBkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAobWFwLnR5cGVzW3RhZ0NvZGVdID09PSAnYmluYXJ5Jykge1xuICAgICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhVmlldy5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpXSlcbiAgICB9XG4gICAgaWYgKG1hcC50eXBlc1t0YWdDb2RlXSA9PT0gJ1VpbnQxNicpIHtcbiAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gZ2V0U3RyaW5nVmFsdWUoZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVzIElQVEMgdmFsdWUgd2l0aCBleGlzdGluZyBvbmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgRXhpc3RpbmcgSVBUQyBmaWVsZCB2YWx1ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3VmFsdWUgTmV3IElQVEMgZmllbGQgdmFsdWVcbiAgICogQHJldHVybnMge29iamVjdH0gUmVzdWx0aW5nIElQVEMgZmllbGQgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbWJpbmVUYWdWYWx1ZXModmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBuZXdWYWx1ZVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YWx1ZS5wdXNoKG5ld1ZhbHVlKVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIG5ld1ZhbHVlXVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBJUFRDIHRhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IERhdGEgdmlldyBpbnRlcmZhY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRPZmZzZXQgU2VnbWVudCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRMZW5ndGggU2VnbWVudCBsZW5ndGhcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBleHBvcnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNsdWRlVGFncyBNYXAgb2YgdGFncyB0byBpbmNsdWRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBleGNsdWRlVGFncyBNYXAgb2YgdGFncyB0byBleGNsdWRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUlwdGNUYWdzKFxuICAgIGRhdGFWaWV3LFxuICAgIHNlZ21lbnRPZmZzZXQsXG4gICAgc2VnbWVudExlbmd0aCxcbiAgICBkYXRhLFxuICAgIGluY2x1ZGVUYWdzLFxuICAgIGV4Y2x1ZGVUYWdzXG4gICkge1xuICAgIHZhciB2YWx1ZSwgdGFnU2l6ZSwgdGFnQ29kZVxuICAgIHZhciBzZWdtZW50RW5kID0gc2VnbWVudE9mZnNldCArIHNlZ21lbnRMZW5ndGhcbiAgICB2YXIgb2Zmc2V0ID0gc2VnbWVudE9mZnNldFxuICAgIHdoaWxlIChvZmZzZXQgPCBzZWdtZW50RW5kKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgPT09IDB4MWMgJiYgLy8gdGFnIG1hcmtlclxuICAgICAgICBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAxKSA9PT0gMHgwMiAvLyByZWNvcmQgbnVtYmVyLCBvbmx5IGhhbmRsZXMgdjJcbiAgICAgICkge1xuICAgICAgICB0YWdDb2RlID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMilcbiAgICAgICAgaWYgKFxuICAgICAgICAgICghaW5jbHVkZVRhZ3MgfHwgaW5jbHVkZVRhZ3NbdGFnQ29kZV0pICYmXG4gICAgICAgICAgKCFleGNsdWRlVGFncyB8fCAhZXhjbHVkZVRhZ3NbdGFnQ29kZV0pXG4gICAgICAgICkge1xuICAgICAgICAgIHRhZ1NpemUgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQgKyAzKVxuICAgICAgICAgIHZhbHVlID0gZ2V0VGFnVmFsdWUodGFnQ29kZSwgZGF0YS5pcHRjLCBkYXRhVmlldywgb2Zmc2V0ICsgNSwgdGFnU2l6ZSlcbiAgICAgICAgICBkYXRhLmlwdGNbdGFnQ29kZV0gPSBjb21iaW5lVGFnVmFsdWVzKGRhdGEuaXB0Y1t0YWdDb2RlXSwgdmFsdWUpXG4gICAgICAgICAgaWYgKGRhdGEuaXB0Y09mZnNldHMpIHtcbiAgICAgICAgICAgIGRhdGEuaXB0Y09mZnNldHNbdGFnQ29kZV0gPSBvZmZzZXRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSAxXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGZpZWxkIHNlZ21lbnQgc3RhcnRzIGF0IG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFNlZ21lbnQgb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmICc4QklNPEVPVD48RU9UPicgZXhpc3RzIGF0IG9mZnNldFxuICAgKi9cbiAgZnVuY3Rpb24gaXNTZWdtZW50U3RhcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiAoXG4gICAgICBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0KSA9PT0gMHgzODQyNDk0ZCAmJiAvLyBQaG90b3Nob3Agc2VnbWVudCBzdGFydFxuICAgICAgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDQpID09PSAweDA0MDQgLy8gSVBUQyBzZWdtZW50IHN0YXJ0XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGVhZGVyIGxlbmd0aC5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFNlZ21lbnQgb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEhlYWRlciBsZW5ndGhcbiAgICovXG4gIGZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDcpXG4gICAgaWYgKGxlbmd0aCAlIDIgIT09IDApIGxlbmd0aCArPSAxXG4gICAgLy8gQ2hlY2sgZm9yIHByZSBwaG90b3Nob3AgNiBmb3JtYXRcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBBbHdheXMgNFxuICAgICAgbGVuZ3RoID0gNFxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBsb2FkSW1hZ2UucGFyc2VJcHRjRGF0YSA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlSXB0Yykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBtYXJrZXJMZW5ndGggPSBvZmZzZXQgKyBsZW5ndGhcbiAgICB3aGlsZSAob2Zmc2V0ICsgOCA8IG1hcmtlckxlbmd0aCkge1xuICAgICAgaWYgKGlzU2VnbWVudFN0YXJ0KGRhdGFWaWV3LCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgICAgdmFyIHNlZ21lbnRPZmZzZXQgPSBvZmZzZXQgKyA4ICsgaGVhZGVyTGVuZ3RoXG4gICAgICAgIGlmIChzZWdtZW50T2Zmc2V0ID4gbWFya2VyTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBJUFRDIGRhdGE6IEludmFsaWQgc2VnbWVudCBvZmZzZXQuJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWdtZW50TGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDYgKyBoZWFkZXJMZW5ndGgpXG4gICAgICAgIGlmIChvZmZzZXQgKyBzZWdtZW50TGVuZ3RoID4gbWFya2VyTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBJUFRDIGRhdGE6IEludmFsaWQgc2VnbWVudCBzaXplLicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIGlwdGMgb2JqZWN0IHRvIHN0b3JlIHRoZSB0YWdzOlxuICAgICAgICBkYXRhLmlwdGMgPSBuZXcgSXB0Y01hcCgpXG4gICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlSXB0Y09mZnNldHMpIHtcbiAgICAgICAgICBkYXRhLmlwdGNPZmZzZXRzID0gbmV3IElwdGNNYXAoKVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlSXB0Y1RhZ3MoXG4gICAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgICAgc2VnbWVudE9mZnNldCxcbiAgICAgICAgICBzZWdtZW50TGVuZ3RoLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgb3B0aW9ucy5pbmNsdWRlSXB0Y1RhZ3MsXG4gICAgICAgICAgb3B0aW9ucy5leGNsdWRlSXB0Y1RhZ3MgfHwgeyAyMDI6IHRydWUgfSAvLyBPYmplY3RQcmV2aWV3RGF0YVxuICAgICAgICApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBvZmZzZXQgKz0gMVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVycyB0aGlzIElQVEMgcGFyc2VyIGZvciB0aGUgQVBQMTMgSlBFRyBtZXRhZGF0YSBzZWdtZW50OlxuICBsb2FkSW1hZ2UubWV0YURhdGFQYXJzZXJzLmpwZWdbMHhmZmVkXS5wdXNoKGxvYWRJbWFnZS5wYXJzZUlwdGNEYXRhKVxuXG4gIGxvYWRJbWFnZS5JcHRjTWFwID0gSXB0Y01hcFxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBwYXJzZU1ldGFEYXRhIGNhbGxiYWNrIGRhdGE6XG4gIC8vIC0gaXB0YzogVGhlIGlwdGMgdGFncywgcGFyc2VkIGJ5IHRoZSBwYXJzZUlwdGNEYXRhIG1ldGhvZFxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBvcHRpb25zIHRvIHRoZSBwYXJzZU1ldGFEYXRhIG1ldGhvZDpcbiAgLy8gLSBkaXNhYmxlSXB0YzogRGlzYWJsZXMgSVBUQyBwYXJzaW5nIHdoZW4gdHJ1ZS5cbiAgLy8gLSBkaXNhYmxlSXB0Y09mZnNldHM6IERpc2FibGVzIHN0b3JpbmcgSVBUQyB0YWcgb2Zmc2V0cyB3aGVuIHRydWUuXG4gIC8vIC0gaW5jbHVkZUlwdGNUYWdzOiBBIG1hcCBvZiBJUFRDIHRhZ3MgdG8gaW5jbHVkZSBmb3IgcGFyc2luZy5cbiAgLy8gLSBleGNsdWRlSXB0Y1RhZ3M6IEEgbWFwIG9mIElQVEMgdGFncyB0byBleGNsdWRlIGZyb20gcGFyc2luZy5cbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-meta.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-meta.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n  var originalTransform = loadImage.transform\n\n  var blobSlice =\n    global.Blob &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  var bufferSlice =\n    (global.ArrayBuffer && ArrayBuffer.prototype.slice) ||\n    function (begin, end) {\n      // Polyfill for IE10, which does not support ArrayBuffer.slice\n      // eslint-disable-next-line no-param-reassign\n      end = end || this.byteLength - begin\n      var arr1 = new Uint8Array(this, begin, end)\n      var arr2 = new Uint8Array(end)\n      arr2.set(arr1)\n      return arr2.buffer\n    }\n\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n  function parseMetaData(file, callback, options, data) {\n    var that = this\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n    function executor(resolve, reject) {\n      if (\n        !(\n          global.DataView &&\n          blobSlice &&\n          file &&\n          file.size >= 12 &&\n          file.type === 'image/jpeg'\n        )\n      ) {\n        // Nothing to parse\n        return resolve(data)\n      }\n      // 256 KiB should contain all EXIF/ICC/IPTC segments:\n      var maxMetaDataSize = options.maxMetaDataSize || 262144\n      if (\n        !loadImage.readFile(\n          blobSlice.call(file, 0, maxMetaDataSize),\n          function (buffer) {\n            // Note on endianness:\n            // Since the marker and length bytes in JPEG files are always\n            // stored in big endian order, we can leave the endian parameter\n            // of the DataView methods undefined, defaulting to big endian.\n            var dataView = new DataView(buffer)\n            // Check for the JPEG marker (0xffd8):\n            if (dataView.getUint16(0) !== 0xffd8) {\n              return reject(\n                new Error('Invalid JPEG file: Missing JPEG marker.')\n              )\n            }\n            var offset = 2\n            var maxOffset = dataView.byteLength - 4\n            var headLength = offset\n            var markerBytes\n            var markerLength\n            var parsers\n            var i\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific metadata like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid JPEG metadata: Invalid segment size.')\n                  break\n                }\n                parsers = metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the metadata\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              data.imageHead = bufferSlice.call(buffer, 0, headLength)\n            }\n            resolve(data)\n          },\n          reject,\n          'readAsArrayBuffer'\n        )\n      ) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data)\n      }\n    }\n    options = options || {} // eslint-disable-line no-param-reassign\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {} // eslint-disable-line no-param-reassign\n      data = options // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    data = data || {} // eslint-disable-line no-param-reassign\n    return executor(callback, callback)\n  }\n\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    })\n  }\n\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n  function replaceHead(blob, head, callback) {\n    var options = { maxMetaDataSize: 1024, disableMetaDataParsers: true }\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head)\n      })\n    }\n    parseMetaData(\n      blob,\n      function (data) {\n        callback(replaceJPEGHead(blob, data.imageHead, head))\n      },\n      options\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {} // eslint-disable-line no-param-reassign\n      parseMetaData(\n        file,\n        function (result) {\n          if (result !== data) {\n            // eslint-disable-next-line no-console\n            if (global.console) console.log(result)\n            result = data // eslint-disable-line no-param-reassign\n          }\n          originalTransform.call(\n            loadImage,\n            img,\n            options,\n            callback,\n            file,\n            result\n          )\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n\n  loadImage.blobSlice = blobSlice\n  loadImage.bufferSlice = bufferSlice\n  loadImage.replaceHead = replaceHead\n  loadImage.parseMetaData = parseMetaData\n  loadImage.metaDataParsers = metaDataParsers\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3JDLElBQUksS0FBSyxFQUtOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsYUFBYTtBQUMxQixhQUFhLFVBQVU7QUFDdkIsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1tZXRhLmpzPzU4NTkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBNZXRhXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIEltYWdlIG1ldGFkYXRhIGhhbmRsaW5nIGltcGxlbWVudGF0aW9uXG4gKiBiYXNlZCBvbiB0aGUgaGVscCBhbmQgY29udHJpYnV0aW9uIG9mXG4gKiBBY2hpbSBTdMO2aHIuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIFByb21pc2UsIERhdGFWaWV3LCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIGdsb2JhbCA9IGxvYWRJbWFnZS5nbG9iYWxcbiAgdmFyIG9yaWdpbmFsVHJhbnNmb3JtID0gbG9hZEltYWdlLnRyYW5zZm9ybVxuXG4gIHZhciBibG9iU2xpY2UgPVxuICAgIGdsb2JhbC5CbG9iICYmXG4gICAgKEJsb2IucHJvdG90eXBlLnNsaWNlIHx8XG4gICAgICBCbG9iLnByb3RvdHlwZS53ZWJraXRTbGljZSB8fFxuICAgICAgQmxvYi5wcm90b3R5cGUubW96U2xpY2UpXG5cbiAgdmFyIGJ1ZmZlclNsaWNlID1cbiAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSkgfHxcbiAgICBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgICAgLy8gUG9seWZpbGwgZm9yIElFMTAsIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgQXJyYXlCdWZmZXIuc2xpY2VcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZW5kID0gZW5kIHx8IHRoaXMuYnl0ZUxlbmd0aCAtIGJlZ2luXG4gICAgICB2YXIgYXJyMSA9IG5ldyBVaW50OEFycmF5KHRoaXMsIGJlZ2luLCBlbmQpXG4gICAgICB2YXIgYXJyMiA9IG5ldyBVaW50OEFycmF5KGVuZClcbiAgICAgIGFycjIuc2V0KGFycjEpXG4gICAgICByZXR1cm4gYXJyMi5idWZmZXJcbiAgICB9XG5cbiAgdmFyIG1ldGFEYXRhUGFyc2VycyA9IHtcbiAgICBqcGVnOiB7XG4gICAgICAweGZmZTE6IFtdLCAvLyBBUFAxIG1hcmtlclxuICAgICAgMHhmZmVkOiBbXSAvLyBBUFAxMyBtYXJrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGltYWdlIG1ldGFkYXRhIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCBhbiBvYmplY3QgYXJndW1lbnRcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnR5OlxuICAgKiAtIGltYWdlSGVhZDogVGhlIGNvbXBsZXRlIGltYWdlIGhlYWQgYXMgQXJyYXlCdWZmZXJcbiAgICogVGhlIG9wdGlvbnMgYXJndW1lbnQgYWNjZXB0cyBhbiBvYmplY3QgYW5kIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICogLSBtYXhNZXRhRGF0YVNpemU6IERlZmluZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHBhcnNlLlxuICAgKiAtIGRpc2FibGVJbWFnZUhlYWQ6IERpc2FibGVzIGNyZWF0aW5nIHRoZSBpbWFnZUhlYWQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gZmlsZSBCbG9iIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gUGFyc2luZyBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YV0gUmVzdWx0IGRhdGEgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD58dW5kZWZpbmVkfSBSZXR1cm5zIFByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW4uXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZU1ldGFEYXRhKGZpbGUsIGNhbGxiYWNrLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSBleGVjdXRvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBSZXNvbHV0aW9uIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IFJlamVjdGlvbiBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IFVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKFxuICAgICAgICAhKFxuICAgICAgICAgIGdsb2JhbC5EYXRhVmlldyAmJlxuICAgICAgICAgIGJsb2JTbGljZSAmJlxuICAgICAgICAgIGZpbGUgJiZcbiAgICAgICAgICBmaWxlLnNpemUgPj0gMTIgJiZcbiAgICAgICAgICBmaWxlLnR5cGUgPT09ICdpbWFnZS9qcGVnJ1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBwYXJzZVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhKVxuICAgICAgfVxuICAgICAgLy8gMjU2IEtpQiBzaG91bGQgY29udGFpbiBhbGwgRVhJRi9JQ0MvSVBUQyBzZWdtZW50czpcbiAgICAgIHZhciBtYXhNZXRhRGF0YVNpemUgPSBvcHRpb25zLm1heE1ldGFEYXRhU2l6ZSB8fCAyNjIxNDRcbiAgICAgIGlmIChcbiAgICAgICAgIWxvYWRJbWFnZS5yZWFkRmlsZShcbiAgICAgICAgICBibG9iU2xpY2UuY2FsbChmaWxlLCAwLCBtYXhNZXRhRGF0YVNpemUpLFxuICAgICAgICAgIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgb24gZW5kaWFubmVzczpcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBtYXJrZXIgYW5kIGxlbmd0aCBieXRlcyBpbiBKUEVHIGZpbGVzIGFyZSBhbHdheXNcbiAgICAgICAgICAgIC8vIHN0b3JlZCBpbiBiaWcgZW5kaWFuIG9yZGVyLCB3ZSBjYW4gbGVhdmUgdGhlIGVuZGlhbiBwYXJhbWV0ZXJcbiAgICAgICAgICAgIC8vIG9mIHRoZSBEYXRhVmlldyBtZXRob2RzIHVuZGVmaW5lZCwgZGVmYXVsdGluZyB0byBiaWcgZW5kaWFuLlxuICAgICAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgSlBFRyBtYXJrZXIgKDB4ZmZkOCk6XG4gICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KDApICE9PSAweGZmZDgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0ludmFsaWQgSlBFRyBmaWxlOiBNaXNzaW5nIEpQRUcgbWFya2VyLicpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAyXG4gICAgICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gZGF0YVZpZXcuYnl0ZUxlbmd0aCAtIDRcbiAgICAgICAgICAgIHZhciBoZWFkTGVuZ3RoID0gb2Zmc2V0XG4gICAgICAgICAgICB2YXIgbWFya2VyQnl0ZXNcbiAgICAgICAgICAgIHZhciBtYXJrZXJMZW5ndGhcbiAgICAgICAgICAgIHZhciBwYXJzZXJzXG4gICAgICAgICAgICB2YXIgaVxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICBtYXJrZXJCeXRlcyA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQpXG4gICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgQVBQbiAoMHhmZmVOKSBhbmQgQ09NICgweGZmZmUpIG1hcmtlcnMsXG4gICAgICAgICAgICAgIC8vIHdoaWNoIGNvbnRhaW4gYXBwbGljYXRpb24tc3BlY2lmaWMgbWV0YWRhdGEgbGlrZVxuICAgICAgICAgICAgICAvLyBFeGlmLCBJQ0MgYW5kIElQVEMgZGF0YSBhbmQgdGV4dCBjb21tZW50czpcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChtYXJrZXJCeXRlcyA+PSAweGZmZTAgJiYgbWFya2VyQnl0ZXMgPD0gMHhmZmVmKSB8fFxuICAgICAgICAgICAgICAgIG1hcmtlckJ5dGVzID09PSAweGZmZmVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1hcmtlciBieXRlcyAoMikgYXJlIGFsd2F5cyBmb2xsb3dlZCBieVxuICAgICAgICAgICAgICAgIC8vIHRoZSBsZW5ndGggYnl0ZXMgKDIpLCBpbmRpY2F0aW5nIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbWFya2VyIHNlZ21lbnQsIHdoaWNoIGluY2x1ZGVzIHRoZSBsZW5ndGggYnl0ZXMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IG5vdCB0aGUgbWFya2VyIGJ5dGVzLCBzbyB3ZSBhZGQgMjpcbiAgICAgICAgICAgICAgICBtYXJrZXJMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMikgKyAyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIG1hcmtlckxlbmd0aCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBKUEVHIG1ldGFkYXRhOiBJbnZhbGlkIHNlZ21lbnQgc2l6ZS4nKVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VycyA9IG1ldGFEYXRhUGFyc2Vycy5qcGVnW21hcmtlckJ5dGVzXVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJzICYmICFvcHRpb25zLmRpc2FibGVNZXRhRGF0YVBhcnNlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcnNbaV0uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG1hcmtlckxlbmd0aFxuICAgICAgICAgICAgICAgIGhlYWRMZW5ndGggPSBvZmZzZXRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgYW4gQVBQbiBvciBDT00gbWFya2VyLCBwcm9iYWJseSBzYWZlIHRvXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoYXQgdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBtZXRhZGF0YVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ldGEgbGVuZ3RoIG11c3QgYmUgbG9uZ2VyIHRoYW4gSlBFRyBtYXJrZXIgKDIpXG4gICAgICAgICAgICAvLyBwbHVzIEFQUG4gbWFya2VyICgyKSwgZm9sbG93ZWQgYnkgbGVuZ3RoIGJ5dGVzICgyKTpcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlSW1hZ2VIZWFkICYmIGhlYWRMZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgIGRhdGEuaW1hZ2VIZWFkID0gYnVmZmVyU2xpY2UuY2FsbChidWZmZXIsIDAsIGhlYWRMZW5ndGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgJ3JlYWRBc0FycmF5QnVmZmVyJ1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgdGhlIEZpbGVSZWFkZXIgaW50ZXJmYWNlLCBub3RoaW5nIHRvIHBhcnNlXG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGlmIChnbG9iYWwuUHJvbWlzZSAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSBjYWxsYmFjayB8fCB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBkYXRhID0gb3B0aW9ucyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgfVxuICAgIGRhdGEgPSBkYXRhIHx8IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZXR1cm4gZXhlY3V0b3IoY2FsbGJhY2ssIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBoZWFkIG9mIGEgSlBFRyBCbG9iXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYiBCbG9iIG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBvbGRIZWFkIE9sZCBKUEVHIGhlYWRcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gbmV3SGVhZCBOZXcgSlBFRyBoZWFkXG4gICAqIEByZXR1cm5zIHtCbG9ifSBDb21iaW5lZCBCbG9iXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSlBFR0hlYWQoYmxvYiwgb2xkSGVhZCwgbmV3SGVhZCkge1xuICAgIGlmICghYmxvYiB8fCAhb2xkSGVhZCB8fCAhbmV3SGVhZCkgcmV0dXJuIG51bGxcbiAgICByZXR1cm4gbmV3IEJsb2IoW25ld0hlYWQsIGJsb2JTbGljZS5jYWxsKGJsb2IsIG9sZEhlYWQuYnl0ZUxlbmd0aCldLCB7XG4gICAgICB0eXBlOiAnaW1hZ2UvanBlZydcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBpbWFnZSBoZWFkIG9mIGEgSlBFRyBibG9iIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICogUmV0dXJucyBhIFByb21pc2Ugb3IgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIG5ldyBCbG9iLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgQmxvYiBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaGVhZCBOZXcgSlBFRyBoZWFkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8QmxvYnxudWxsPnx1bmRlZmluZWR9IENvbWJpbmVkIEJsb2JcbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIZWFkKGJsb2IsIGhlYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IG1heE1ldGFEYXRhU2l6ZTogMTAyNCwgZGlzYWJsZU1ldGFEYXRhUGFyc2VyczogdHJ1ZSB9XG4gICAgaWYgKCFjYWxsYmFjayAmJiBnbG9iYWwuUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHBhcnNlTWV0YURhdGEoYmxvYiwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUpQRUdIZWFkKGJsb2IsIGRhdGEuaW1hZ2VIZWFkLCBoZWFkKVxuICAgICAgfSlcbiAgICB9XG4gICAgcGFyc2VNZXRhRGF0YShcbiAgICAgIGJsb2IsXG4gICAgICBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhyZXBsYWNlSlBFR0hlYWQoYmxvYiwgZGF0YS5pbWFnZUhlYWQsIGhlYWQpKVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG4gIH1cblxuICBsb2FkSW1hZ2UudHJhbnNmb3JtID0gZnVuY3Rpb24gKGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpIHtcbiAgICBpZiAobG9hZEltYWdlLnJlcXVpcmVzTWV0YURhdGEob3B0aW9ucykpIHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHBhcnNlTWV0YURhdGEoXG4gICAgICAgIGZpbGUsXG4gICAgICAgIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBkYXRhKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlKSBjb25zb2xlLmxvZyhyZXN1bHQpXG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxUcmFuc2Zvcm0uY2FsbChcbiAgICAgICAgICAgIGxvYWRJbWFnZSxcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGFcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxUcmFuc2Zvcm0uYXBwbHkobG9hZEltYWdlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgbG9hZEltYWdlLmJsb2JTbGljZSA9IGJsb2JTbGljZVxuICBsb2FkSW1hZ2UuYnVmZmVyU2xpY2UgPSBidWZmZXJTbGljZVxuICBsb2FkSW1hZ2UucmVwbGFjZUhlYWQgPSByZXBsYWNlSGVhZFxuICBsb2FkSW1hZ2UucGFyc2VNZXRhRGF0YSA9IHBhcnNlTWV0YURhdGFcbiAgbG9hZEltYWdlLm1ldGFEYXRhUGFyc2VycyA9IG1ldGFEYXRhUGFyc2Vyc1xufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-meta.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-orientation.js":
/*!**********************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-orientation.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/*\nExif orientation values to correctly display the letter F:\n\n    1             2\n  ██████        ██████\n  ██                ██\n  ████            ████\n  ██                ██\n  ██                ██\n\n    3             4\n      ██        ██\n      ██        ██\n    ████        ████\n      ██        ██\n  ██████        ██████\n\n    5             6\n██████████    ██\n██  ██        ██  ██\n██            ██████████\n\n    7             8\n        ██    ██████████\n    ██  ██        ██  ██\n██████████            ██\n\n*/\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n  var originalRequiresCanvas = loadImage.requiresCanvas\n  var originalRequiresMetaData = loadImage.requiresMetaData\n  var originalTransformCoordinates = loadImage.transformCoordinates\n  var originalGetTransformedOptions = loadImage.getTransformedOptions\n\n  ;(function ($) {\n    // Guard for non-browser environments (e.g. server-side rendering):\n    if (!$.global.document) return\n    // black+white 3x2 JPEG, with the following meta information set:\n    // - EXIF Orientation: 6 (Rotated 90° CCW)\n    // Image data layout (B=black, F=white):\n    // BFF\n    // BBB\n    var testImageURL =\n      'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n      'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n      'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n      'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/x' +\n      'ABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAA' +\n      'AAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQ' +\n      'voP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXw' +\n      'H/9k='\n    var img = document.createElement('img')\n    img.onload = function () {\n      // Check if the browser supports automatic image orientation:\n      $.orientation = img.width === 2 && img.height === 3\n      if ($.orientation) {\n        var canvas = $.createCanvas(1, 1, true)\n        var ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 1, 1, 1, 1, 0, 0, 1, 1)\n        // Check if the source image coordinates (sX, sY, sWidth, sHeight) are\n        // correctly applied to the auto-orientated image, which should result\n        // in a white opaque pixel (e.g. in Safari).\n        // Browsers that show a transparent pixel (e.g. Chromium) fail to crop\n        // auto-oriented images correctly and require a workaround, e.g.\n        // drawing the complete source image to an intermediate canvas first.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1074354\n        $.orientationCropBug =\n          ctx.getImageData(0, 0, 1, 1).data.toString() !== '255,255,255,255'\n      }\n    }\n    img.src = testImageURL\n  })(loadImage)\n\n  /**\n   * Determines if the orientation requires a canvas element.\n   *\n   * @param {object} [options] Options object\n   * @param {boolean} [withMetaData] Is metadata required for orientation\n   * @returns {boolean} Returns true if orientation requires canvas/meta\n   */\n  function requiresCanvasOrientation(options, withMetaData) {\n    var orientation = options && options.orientation\n    return (\n      // Exif orientation for browsers without automatic image orientation:\n      (orientation === true && !loadImage.orientation) ||\n      // Orientation reset for browsers with automatic image orientation:\n      (orientation === 1 && loadImage.orientation) ||\n      // Orientation to defined value, requires meta for orientation reset only:\n      ((!withMetaData || loadImage.orientation) &&\n        orientation > 1 &&\n        orientation < 9)\n    )\n  }\n\n  /**\n   * Determines if the image requires an orientation change.\n   *\n   * @param {number} [orientation] Defined orientation value\n   * @param {number} [autoOrientation] Auto-orientation based on Exif data\n   * @returns {boolean} Returns true if an orientation change is required\n   */\n  function requiresOrientationChange(orientation, autoOrientation) {\n    return (\n      orientation !== autoOrientation &&\n      ((orientation === 1 && autoOrientation > 1 && autoOrientation < 9) ||\n        (orientation > 1 && orientation < 9))\n    )\n  }\n\n  /**\n   * Determines orientation combinations that require a rotation by 180°.\n   *\n   * The following is a list of combinations that return true:\n   *\n   * 2 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)\n   * 4 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)\n   *\n   * 5 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)\n   * 7 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)\n   *\n   * 6 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)\n   * 8 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)\n   *\n   * @param {number} [orientation] Defined orientation value\n   * @param {number} [autoOrientation] Auto-orientation based on Exif data\n   * @returns {boolean} Returns true if rotation by 180° is required\n   */\n  function requiresRot180(orientation, autoOrientation) {\n    if (autoOrientation > 1 && autoOrientation < 9) {\n      switch (orientation) {\n        case 2:\n        case 4:\n          return autoOrientation > 4\n        case 5:\n        case 7:\n          return autoOrientation % 2 === 0\n        case 6:\n        case 8:\n          return (\n            autoOrientation === 2 ||\n            autoOrientation === 4 ||\n            autoOrientation === 5 ||\n            autoOrientation === 7\n          )\n      }\n    }\n    return false\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.requiresCanvas = function (options) {\n    return (\n      requiresCanvasOrientation(options) ||\n      originalRequiresCanvas.call(loadImage, options)\n    )\n  }\n\n  // Determines if metadata should be loaded automatically:\n  loadImage.requiresMetaData = function (options) {\n    return (\n      requiresCanvasOrientation(options, true) ||\n      originalRequiresMetaData.call(loadImage, options)\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      img,\n      options,\n      function (img, data) {\n        if (data) {\n          var autoOrientation =\n            loadImage.orientation && data.exif && data.exif.get('Orientation')\n          if (autoOrientation > 4 && autoOrientation < 9) {\n            // Automatic image orientation switched image dimensions\n            var originalWidth = data.originalWidth\n            var originalHeight = data.originalHeight\n            data.originalWidth = originalHeight\n            data.originalHeight = originalWidth\n          }\n        }\n        callback(img, data)\n      },\n      file,\n      data\n    )\n  }\n\n  // Transforms coordinate and dimension options\n  // based on the given orientation option:\n  loadImage.getTransformedOptions = function (img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts)\n    var exifOrientation = data.exif && data.exif.get('Orientation')\n    var orientation = options.orientation\n    var autoOrientation = loadImage.orientation && exifOrientation\n    if (orientation === true) orientation = exifOrientation\n    if (!requiresOrientationChange(orientation, autoOrientation)) {\n      return options\n    }\n    var top = options.top\n    var right = options.right\n    var bottom = options.bottom\n    var left = options.left\n    var newOptions = {}\n    for (var i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.orientation = orientation\n    if (\n      (orientation > 4 && !(autoOrientation > 4)) ||\n      (orientation < 5 && autoOrientation > 4)\n    ) {\n      // Image dimensions and target dimensions are switched\n      newOptions.maxWidth = options.maxHeight\n      newOptions.maxHeight = options.maxWidth\n      newOptions.minWidth = options.minHeight\n      newOptions.minHeight = options.minWidth\n      newOptions.sourceWidth = options.sourceHeight\n      newOptions.sourceHeight = options.sourceWidth\n    }\n    if (autoOrientation > 1) {\n      // Browsers which correctly apply source image coordinates to\n      // auto-oriented images\n      switch (autoOrientation) {\n        case 2:\n          // Horizontal flip\n          right = options.left\n          left = options.right\n          break\n        case 3:\n          // 180° Rotate CCW\n          top = options.bottom\n          right = options.left\n          bottom = options.top\n          left = options.right\n          break\n        case 4:\n          // Vertical flip\n          top = options.bottom\n          bottom = options.top\n          break\n        case 5:\n          // Horizontal flip + 90° Rotate CCW\n          top = options.left\n          right = options.bottom\n          bottom = options.right\n          left = options.top\n          break\n        case 6:\n          // 90° Rotate CCW\n          top = options.left\n          right = options.top\n          bottom = options.right\n          left = options.bottom\n          break\n        case 7:\n          // Vertical flip + 90° Rotate CCW\n          top = options.right\n          right = options.top\n          bottom = options.left\n          left = options.bottom\n          break\n        case 8:\n          // 90° Rotate CW\n          top = options.right\n          right = options.bottom\n          bottom = options.left\n          left = options.top\n          break\n      }\n      // Some orientation combinations require additional rotation by 180°:\n      if (requiresRot180(orientation, autoOrientation)) {\n        var tmpTop = top\n        var tmpRight = right\n        top = bottom\n        right = left\n        bottom = tmpTop\n        left = tmpRight\n      }\n    }\n    newOptions.top = top\n    newOptions.right = right\n    newOptions.bottom = bottom\n    newOptions.left = left\n    // Account for defined browser orientation:\n    switch (orientation) {\n      case 2:\n        // Horizontal flip\n        newOptions.right = left\n        newOptions.left = right\n        break\n      case 3:\n        // 180° Rotate CCW\n        newOptions.top = bottom\n        newOptions.right = left\n        newOptions.bottom = top\n        newOptions.left = right\n        break\n      case 4:\n        // Vertical flip\n        newOptions.top = bottom\n        newOptions.bottom = top\n        break\n      case 5:\n        // Vertical flip + 90° Rotate CW\n        newOptions.top = left\n        newOptions.right = bottom\n        newOptions.bottom = right\n        newOptions.left = top\n        break\n      case 6:\n        // 90° Rotate CW\n        newOptions.top = right\n        newOptions.right = bottom\n        newOptions.bottom = left\n        newOptions.left = top\n        break\n      case 7:\n        // Horizontal flip + 90° Rotate CW\n        newOptions.top = right\n        newOptions.right = top\n        newOptions.bottom = left\n        newOptions.left = bottom\n        break\n      case 8:\n        // 90° Rotate CCW\n        newOptions.top = left\n        newOptions.right = top\n        newOptions.bottom = right\n        newOptions.left = bottom\n        break\n    }\n    return newOptions\n  }\n\n  // Transform image orientation based on the given EXIF orientation option:\n  loadImage.transformCoordinates = function (canvas, options, data) {\n    originalTransformCoordinates.call(loadImage, canvas, options, data)\n    var orientation = options.orientation\n    var autoOrientation =\n      loadImage.orientation && data.exif && data.exif.get('Orientation')\n    if (!requiresOrientationChange(orientation, autoOrientation)) {\n      return\n    }\n    var ctx = canvas.getContext('2d')\n    var width = canvas.width\n    var height = canvas.height\n    var sourceWidth = width\n    var sourceHeight = height\n    if (\n      (orientation > 4 && !(autoOrientation > 4)) ||\n      (orientation < 5 && autoOrientation > 4)\n    ) {\n      // Image dimensions and target dimensions are switched\n      canvas.width = height\n      canvas.height = width\n    }\n    if (orientation > 4) {\n      // Destination and source dimensions are switched\n      sourceWidth = height\n      sourceHeight = width\n    }\n    // Reset automatic browser orientation:\n    switch (autoOrientation) {\n      case 2:\n        // Horizontal flip\n        ctx.translate(sourceWidth, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180° Rotate CCW\n        ctx.translate(sourceWidth, sourceHeight)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // Vertical flip\n        ctx.translate(0, sourceHeight)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // Horizontal flip + 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.scale(-1, 1)\n        break\n      case 6:\n        // 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-sourceWidth, 0)\n        break\n      case 7:\n        // Vertical flip + 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-sourceWidth, sourceHeight)\n        ctx.scale(1, -1)\n        break\n      case 8:\n        // 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -sourceHeight)\n        break\n    }\n    // Some orientation combinations require additional rotation by 180°:\n    if (requiresRot180(orientation, autoOrientation)) {\n      ctx.translate(sourceWidth, sourceHeight)\n      ctx.rotate(Math.PI)\n    }\n    switch (orientation) {\n      case 2:\n        // Horizontal flip\n        ctx.translate(width, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180° Rotate CCW\n        ctx.translate(width, height)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // Vertical flip\n        ctx.translate(0, height)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // Vertical flip + 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.scale(1, -1)\n        break\n      case 6:\n        // 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -height)\n        break\n      case 7:\n        // Horizontal flip + 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(width, -height)\n        ctx.scale(-1, 1)\n        break\n      case 8:\n        // 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-width, 0)\n        break\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utb3JpZW50YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsRUFBRSx5R0FBb0IsRUFBRSx1R0FBbUIsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ2hGLElBQUksS0FBSyxFQVNOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utb3JpZW50YXRpb24uanM/NTY5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIE9yaWVudGF0aW9uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLypcbkV4aWYgb3JpZW50YXRpb24gdmFsdWVzIHRvIGNvcnJlY3RseSBkaXNwbGF5IHRoZSBsZXR0ZXIgRjpcblxuICAgIDEgICAgICAgICAgICAgMlxuICDilojilojilojilojilojiloggICAgICAgIOKWiOKWiOKWiOKWiOKWiOKWiFxuICDilojiloggICAgICAgICAgICAgICAg4paI4paIXG4gIOKWiOKWiOKWiOKWiCAgICAgICAgICAgIOKWiOKWiOKWiOKWiFxuICDilojiloggICAgICAgICAgICAgICAg4paI4paIXG4gIOKWiOKWiCAgICAgICAgICAgICAgICDilojilohcblxuICAgIDMgICAgICAgICAgICAgNFxuICAgICAg4paI4paIICAgICAgICDilojilohcbiAgICAgIOKWiOKWiCAgICAgICAg4paI4paIXG4gICAg4paI4paI4paI4paIICAgICAgICDilojilojilojilohcbiAgICAgIOKWiOKWiCAgICAgICAg4paI4paIXG4gIOKWiOKWiOKWiOKWiOKWiOKWiCAgICAgICAg4paI4paI4paI4paI4paI4paIXG5cbiAgICA1ICAgICAgICAgICAgIDZcbuKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiCAgICDilojilohcbuKWiOKWiCAg4paI4paIICAgICAgICDilojiloggIOKWiOKWiFxu4paI4paIICAgICAgICAgICAg4paI4paI4paI4paI4paI4paI4paI4paI4paI4paIXG5cbiAgICA3ICAgICAgICAgICAgIDhcbiAgICAgICAg4paI4paIICAgIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiFxuICAgIOKWiOKWiCAg4paI4paIICAgICAgICDilojiloggIOKWiOKWiFxu4paI4paI4paI4paI4paI4paI4paI4paI4paI4paIICAgICAgICAgICAg4paI4paIXG5cbiovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJywgJy4vbG9hZC1pbWFnZS1zY2FsZScsICcuL2xvYWQtaW1hZ2UtbWV0YSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShcbiAgICAgIHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpLFxuICAgICAgcmVxdWlyZSgnLi9sb2FkLWltYWdlLXNjYWxlJyksXG4gICAgICByZXF1aXJlKCcuL2xvYWQtaW1hZ2UtbWV0YScpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIG9yaWdpbmFsVHJhbnNmb3JtID0gbG9hZEltYWdlLnRyYW5zZm9ybVxuICB2YXIgb3JpZ2luYWxSZXF1aXJlc0NhbnZhcyA9IGxvYWRJbWFnZS5yZXF1aXJlc0NhbnZhc1xuICB2YXIgb3JpZ2luYWxSZXF1aXJlc01ldGFEYXRhID0gbG9hZEltYWdlLnJlcXVpcmVzTWV0YURhdGFcbiAgdmFyIG9yaWdpbmFsVHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBsb2FkSW1hZ2UudHJhbnNmb3JtQ29vcmRpbmF0ZXNcbiAgdmFyIG9yaWdpbmFsR2V0VHJhbnNmb3JtZWRPcHRpb25zID0gbG9hZEltYWdlLmdldFRyYW5zZm9ybWVkT3B0aW9uc1xuXG4gIDsoZnVuY3Rpb24gKCQpIHtcbiAgICAvLyBHdWFyZCBmb3Igbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIChlLmcuIHNlcnZlci1zaWRlIHJlbmRlcmluZyk6XG4gICAgaWYgKCEkLmdsb2JhbC5kb2N1bWVudCkgcmV0dXJuXG4gICAgLy8gYmxhY2srd2hpdGUgM3gyIEpQRUcsIHdpdGggdGhlIGZvbGxvd2luZyBtZXRhIGluZm9ybWF0aW9uIHNldDpcbiAgICAvLyAtIEVYSUYgT3JpZW50YXRpb246IDYgKFJvdGF0ZWQgOTDCsCBDQ1cpXG4gICAgLy8gSW1hZ2UgZGF0YSBsYXlvdXQgKEI9YmxhY2ssIEY9d2hpdGUpOlxuICAgIC8vIEJGRlxuICAgIC8vIEJCQlxuICAgIHZhciB0ZXN0SW1hZ2VVUkwgPVxuICAgICAgJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRRQWlSWGhwWmdBQVRVMEFLZ0FBQUFnQUFRRVNBQU1BQUFBQkFBWUFBQUEnICtcbiAgICAgICdBQUFELzJ3Q0VBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBJyArXG4gICAgICAnUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRScgK1xuICAgICAgJ0JBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQWYvQUFCRUlBQUlBQXdNQkVRQUNFUUVERVFIL3gnICtcbiAgICAgICdBQlJBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUtFQUVCQVFBREFRRUFBQUFBQUFBQUFBQUdCUVFEQ0FrQ0J3RUJBQUFBQUFBJyArXG4gICAgICAnQUFBQUFBQUFBQUFBQUFCRUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFQL2FBQXdEQVFBQ0VRTVJBRDhBRzhUOU5mU01FVk1oUScgK1xuICAgICAgJ3ZvUDNmRmlSWitNVEhEaWZhLzk1T0ZTWlU1T3pSenhreWVqdjhjaUVmaFNjZVNYR2pTOGVTZExuWmMySERtNE0zQnhjWHcnICtcbiAgICAgICdILzlrPSdcbiAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXV0b21hdGljIGltYWdlIG9yaWVudGF0aW9uOlxuICAgICAgJC5vcmllbnRhdGlvbiA9IGltZy53aWR0aCA9PT0gMiAmJiBpbWcuaGVpZ2h0ID09PSAzXG4gICAgICBpZiAoJC5vcmllbnRhdGlvbikge1xuICAgICAgICB2YXIgY2FudmFzID0gJC5jcmVhdGVDYW52YXMoMSwgMSwgdHJ1ZSlcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxKVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc291cmNlIGltYWdlIGNvb3JkaW5hdGVzIChzWCwgc1ksIHNXaWR0aCwgc0hlaWdodCkgYXJlXG4gICAgICAgIC8vIGNvcnJlY3RseSBhcHBsaWVkIHRvIHRoZSBhdXRvLW9yaWVudGF0ZWQgaW1hZ2UsIHdoaWNoIHNob3VsZCByZXN1bHRcbiAgICAgICAgLy8gaW4gYSB3aGl0ZSBvcGFxdWUgcGl4ZWwgKGUuZy4gaW4gU2FmYXJpKS5cbiAgICAgICAgLy8gQnJvd3NlcnMgdGhhdCBzaG93IGEgdHJhbnNwYXJlbnQgcGl4ZWwgKGUuZy4gQ2hyb21pdW0pIGZhaWwgdG8gY3JvcFxuICAgICAgICAvLyBhdXRvLW9yaWVudGVkIGltYWdlcyBjb3JyZWN0bHkgYW5kIHJlcXVpcmUgYSB3b3JrYXJvdW5kLCBlLmcuXG4gICAgICAgIC8vIGRyYXdpbmcgdGhlIGNvbXBsZXRlIHNvdXJjZSBpbWFnZSB0byBhbiBpbnRlcm1lZGlhdGUgY2FudmFzIGZpcnN0LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA3NDM1NFxuICAgICAgICAkLm9yaWVudGF0aW9uQ3JvcEJ1ZyA9XG4gICAgICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLnRvU3RyaW5nKCkgIT09ICcyNTUsMjU1LDI1NSwyNTUnXG4gICAgICB9XG4gICAgfVxuICAgIGltZy5zcmMgPSB0ZXN0SW1hZ2VVUkxcbiAgfSkobG9hZEltYWdlKVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBvcmllbnRhdGlvbiByZXF1aXJlcyBhIGNhbnZhcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhNZXRhRGF0YV0gSXMgbWV0YWRhdGEgcmVxdWlyZWQgZm9yIG9yaWVudGF0aW9uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgb3JpZW50YXRpb24gcmVxdWlyZXMgY2FudmFzL21ldGFcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVpcmVzQ2FudmFzT3JpZW50YXRpb24ob3B0aW9ucywgd2l0aE1ldGFEYXRhKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yaWVudGF0aW9uXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIEV4aWYgb3JpZW50YXRpb24gZm9yIGJyb3dzZXJzIHdpdGhvdXQgYXV0b21hdGljIGltYWdlIG9yaWVudGF0aW9uOlxuICAgICAgKG9yaWVudGF0aW9uID09PSB0cnVlICYmICFsb2FkSW1hZ2Uub3JpZW50YXRpb24pIHx8XG4gICAgICAvLyBPcmllbnRhdGlvbiByZXNldCBmb3IgYnJvd3NlcnMgd2l0aCBhdXRvbWF0aWMgaW1hZ2Ugb3JpZW50YXRpb246XG4gICAgICAob3JpZW50YXRpb24gPT09IDEgJiYgbG9hZEltYWdlLm9yaWVudGF0aW9uKSB8fFxuICAgICAgLy8gT3JpZW50YXRpb24gdG8gZGVmaW5lZCB2YWx1ZSwgcmVxdWlyZXMgbWV0YSBmb3Igb3JpZW50YXRpb24gcmVzZXQgb25seTpcbiAgICAgICgoIXdpdGhNZXRhRGF0YSB8fCBsb2FkSW1hZ2Uub3JpZW50YXRpb24pICYmXG4gICAgICAgIG9yaWVudGF0aW9uID4gMSAmJlxuICAgICAgICBvcmllbnRhdGlvbiA8IDkpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGltYWdlIHJlcXVpcmVzIGFuIG9yaWVudGF0aW9uIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcmllbnRhdGlvbl0gRGVmaW5lZCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2F1dG9PcmllbnRhdGlvbl0gQXV0by1vcmllbnRhdGlvbiBiYXNlZCBvbiBFeGlmIGRhdGFcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbiBvcmllbnRhdGlvbiBjaGFuZ2UgaXMgcmVxdWlyZWRcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVpcmVzT3JpZW50YXRpb25DaGFuZ2Uob3JpZW50YXRpb24sIGF1dG9PcmllbnRhdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICBvcmllbnRhdGlvbiAhPT0gYXV0b09yaWVudGF0aW9uICYmXG4gICAgICAoKG9yaWVudGF0aW9uID09PSAxICYmIGF1dG9PcmllbnRhdGlvbiA+IDEgJiYgYXV0b09yaWVudGF0aW9uIDwgOSkgfHxcbiAgICAgICAgKG9yaWVudGF0aW9uID4gMSAmJiBvcmllbnRhdGlvbiA8IDkpKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIG9yaWVudGF0aW9uIGNvbWJpbmF0aW9ucyB0aGF0IHJlcXVpcmUgYSByb3RhdGlvbiBieSAxODDCsC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2YgY29tYmluYXRpb25zIHRoYXQgcmV0dXJuIHRydWU6XG4gICAqXG4gICAqIDIgKGZsaXApID0+IDUgKHJvdDkwLGZsaXApLCA3IChyb3Q5MCxmbGlwKSwgNiAocm90OTApLCA4IChyb3Q5MClcbiAgICogNCAoZmxpcCkgPT4gNSAocm90OTAsZmxpcCksIDcgKHJvdDkwLGZsaXApLCA2IChyb3Q5MCksIDggKHJvdDkwKVxuICAgKlxuICAgKiA1IChyb3Q5MCxmbGlwKSA9PiAyIChmbGlwKSwgNCAoZmxpcCksIDYgKHJvdDkwKSwgOCAocm90OTApXG4gICAqIDcgKHJvdDkwLGZsaXApID0+IDIgKGZsaXApLCA0IChmbGlwKSwgNiAocm90OTApLCA4IChyb3Q5MClcbiAgICpcbiAgICogNiAocm90OTApID0+IDIgKGZsaXApLCA0IChmbGlwKSwgNSAocm90OTAsZmxpcCksIDcgKHJvdDkwLGZsaXApXG4gICAqIDggKHJvdDkwKSA9PiAyIChmbGlwKSwgNCAoZmxpcCksIDUgKHJvdDkwLGZsaXApLCA3IChyb3Q5MCxmbGlwKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29yaWVudGF0aW9uXSBEZWZpbmVkIG9yaWVudGF0aW9uIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXV0b09yaWVudGF0aW9uXSBBdXRvLW9yaWVudGF0aW9uIGJhc2VkIG9uIEV4aWYgZGF0YVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHJvdGF0aW9uIGJ5IDE4MMKwIGlzIHJlcXVpcmVkXG4gICAqL1xuICBmdW5jdGlvbiByZXF1aXJlc1JvdDE4MChvcmllbnRhdGlvbiwgYXV0b09yaWVudGF0aW9uKSB7XG4gICAgaWYgKGF1dG9PcmllbnRhdGlvbiA+IDEgJiYgYXV0b09yaWVudGF0aW9uIDwgOSkge1xuICAgICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gYXV0b09yaWVudGF0aW9uID4gNFxuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gYXV0b09yaWVudGF0aW9uICUgMiA9PT0gMFxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYXV0b09yaWVudGF0aW9uID09PSAyIHx8XG4gICAgICAgICAgICBhdXRvT3JpZW50YXRpb24gPT09IDQgfHxcbiAgICAgICAgICAgIGF1dG9PcmllbnRhdGlvbiA9PT0gNSB8fFxuICAgICAgICAgICAgYXV0b09yaWVudGF0aW9uID09PSA3XG4gICAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIERldGVybWluZXMgaWYgdGhlIHRhcmdldCBpbWFnZSBzaG91bGQgYmUgYSBjYW52YXMgZWxlbWVudDpcbiAgbG9hZEltYWdlLnJlcXVpcmVzQ2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgcmVxdWlyZXNDYW52YXNPcmllbnRhdGlvbihvcHRpb25zKSB8fFxuICAgICAgb3JpZ2luYWxSZXF1aXJlc0NhbnZhcy5jYWxsKGxvYWRJbWFnZSwgb3B0aW9ucylcbiAgICApXG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIG1ldGFkYXRhIHNob3VsZCBiZSBsb2FkZWQgYXV0b21hdGljYWxseTpcbiAgbG9hZEltYWdlLnJlcXVpcmVzTWV0YURhdGEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiAoXG4gICAgICByZXF1aXJlc0NhbnZhc09yaWVudGF0aW9uKG9wdGlvbnMsIHRydWUpIHx8XG4gICAgICBvcmlnaW5hbFJlcXVpcmVzTWV0YURhdGEuY2FsbChsb2FkSW1hZ2UsIG9wdGlvbnMpXG4gICAgKVxuICB9XG5cbiAgbG9hZEltYWdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChpbWcsIG9wdGlvbnMsIGNhbGxiYWNrLCBmaWxlLCBkYXRhKSB7XG4gICAgb3JpZ2luYWxUcmFuc2Zvcm0uY2FsbChcbiAgICAgIGxvYWRJbWFnZSxcbiAgICAgIGltZyxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmdW5jdGlvbiAoaW1nLCBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgdmFyIGF1dG9PcmllbnRhdGlvbiA9XG4gICAgICAgICAgICBsb2FkSW1hZ2Uub3JpZW50YXRpb24gJiYgZGF0YS5leGlmICYmIGRhdGEuZXhpZi5nZXQoJ09yaWVudGF0aW9uJylcbiAgICAgICAgICBpZiAoYXV0b09yaWVudGF0aW9uID4gNCAmJiBhdXRvT3JpZW50YXRpb24gPCA5KSB7XG4gICAgICAgICAgICAvLyBBdXRvbWF0aWMgaW1hZ2Ugb3JpZW50YXRpb24gc3dpdGNoZWQgaW1hZ2UgZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSBkYXRhLm9yaWdpbmFsV2lkdGhcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEhlaWdodCA9IGRhdGEub3JpZ2luYWxIZWlnaHRcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxXaWR0aCA9IG9yaWdpbmFsSGVpZ2h0XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsSGVpZ2h0ID0gb3JpZ2luYWxXaWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhpbWcsIGRhdGEpXG4gICAgICB9LFxuICAgICAgZmlsZSxcbiAgICAgIGRhdGFcbiAgICApXG4gIH1cblxuICAvLyBUcmFuc2Zvcm1zIGNvb3JkaW5hdGUgYW5kIGRpbWVuc2lvbiBvcHRpb25zXG4gIC8vIGJhc2VkIG9uIHRoZSBnaXZlbiBvcmllbnRhdGlvbiBvcHRpb246XG4gIGxvYWRJbWFnZS5nZXRUcmFuc2Zvcm1lZE9wdGlvbnMgPSBmdW5jdGlvbiAoaW1nLCBvcHRzLCBkYXRhKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcmlnaW5hbEdldFRyYW5zZm9ybWVkT3B0aW9ucy5jYWxsKGxvYWRJbWFnZSwgaW1nLCBvcHRzKVxuICAgIHZhciBleGlmT3JpZW50YXRpb24gPSBkYXRhLmV4aWYgJiYgZGF0YS5leGlmLmdldCgnT3JpZW50YXRpb24nKVxuICAgIHZhciBvcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb25cbiAgICB2YXIgYXV0b09yaWVudGF0aW9uID0gbG9hZEltYWdlLm9yaWVudGF0aW9uICYmIGV4aWZPcmllbnRhdGlvblxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gdHJ1ZSkgb3JpZW50YXRpb24gPSBleGlmT3JpZW50YXRpb25cbiAgICBpZiAoIXJlcXVpcmVzT3JpZW50YXRpb25DaGFuZ2Uob3JpZW50YXRpb24sIGF1dG9PcmllbnRhdGlvbikpIHtcbiAgICAgIHJldHVybiBvcHRpb25zXG4gICAgfVxuICAgIHZhciB0b3AgPSBvcHRpb25zLnRvcFxuICAgIHZhciByaWdodCA9IG9wdGlvbnMucmlnaHRcbiAgICB2YXIgYm90dG9tID0gb3B0aW9ucy5ib3R0b21cbiAgICB2YXIgbGVmdCA9IG9wdGlvbnMubGVmdFxuICAgIHZhciBuZXdPcHRpb25zID0ge31cbiAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcbiAgICAgICAgbmV3T3B0aW9uc1tpXSA9IG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICB9XG4gICAgbmV3T3B0aW9ucy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uXG4gICAgaWYgKFxuICAgICAgKG9yaWVudGF0aW9uID4gNCAmJiAhKGF1dG9PcmllbnRhdGlvbiA+IDQpKSB8fFxuICAgICAgKG9yaWVudGF0aW9uIDwgNSAmJiBhdXRvT3JpZW50YXRpb24gPiA0KVxuICAgICkge1xuICAgICAgLy8gSW1hZ2UgZGltZW5zaW9ucyBhbmQgdGFyZ2V0IGRpbWVuc2lvbnMgYXJlIHN3aXRjaGVkXG4gICAgICBuZXdPcHRpb25zLm1heFdpZHRoID0gb3B0aW9ucy5tYXhIZWlnaHRcbiAgICAgIG5ld09wdGlvbnMubWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhXaWR0aFxuICAgICAgbmV3T3B0aW9ucy5taW5XaWR0aCA9IG9wdGlvbnMubWluSGVpZ2h0XG4gICAgICBuZXdPcHRpb25zLm1pbkhlaWdodCA9IG9wdGlvbnMubWluV2lkdGhcbiAgICAgIG5ld09wdGlvbnMuc291cmNlV2lkdGggPSBvcHRpb25zLnNvdXJjZUhlaWdodFxuICAgICAgbmV3T3B0aW9ucy5zb3VyY2VIZWlnaHQgPSBvcHRpb25zLnNvdXJjZVdpZHRoXG4gICAgfVxuICAgIGlmIChhdXRvT3JpZW50YXRpb24gPiAxKSB7XG4gICAgICAvLyBCcm93c2VycyB3aGljaCBjb3JyZWN0bHkgYXBwbHkgc291cmNlIGltYWdlIGNvb3JkaW5hdGVzIHRvXG4gICAgICAvLyBhdXRvLW9yaWVudGVkIGltYWdlc1xuICAgICAgc3dpdGNoIChhdXRvT3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIEhvcml6b250YWwgZmxpcFxuICAgICAgICAgIHJpZ2h0ID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgICAgbGVmdCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgLy8gMTgwwrAgUm90YXRlIENDV1xuICAgICAgICAgIHRvcCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgICAgcmlnaHQgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgICBib3R0b20gPSBvcHRpb25zLnRvcFxuICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIC8vIFZlcnRpY2FsIGZsaXBcbiAgICAgICAgICB0b3AgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICAgIGJvdHRvbSA9IG9wdGlvbnMudG9wXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIC8vIEhvcml6b250YWwgZmxpcCArIDkwwrAgUm90YXRlIENDV1xuICAgICAgICAgIHRvcCA9IG9wdGlvbnMubGVmdFxuICAgICAgICAgIHJpZ2h0ID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgICBib3R0b20gPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgICAgbGVmdCA9IG9wdGlvbnMudG9wXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIC8vIDkwwrAgUm90YXRlIENDV1xuICAgICAgICAgIHRvcCA9IG9wdGlvbnMubGVmdFxuICAgICAgICAgIHJpZ2h0ID0gb3B0aW9ucy50b3BcbiAgICAgICAgICBib3R0b20gPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgICAgbGVmdCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIC8vIFZlcnRpY2FsIGZsaXAgKyA5MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgICB0b3AgPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgICAgcmlnaHQgPSBvcHRpb25zLnRvcFxuICAgICAgICAgIGJvdHRvbSA9IG9wdGlvbnMubGVmdFxuICAgICAgICAgIGxlZnQgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAvLyA5MMKwIFJvdGF0ZSBDV1xuICAgICAgICAgIHRvcCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgICByaWdodCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgICAgYm90dG9tID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgICAgbGVmdCA9IG9wdGlvbnMudG9wXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIC8vIFNvbWUgb3JpZW50YXRpb24gY29tYmluYXRpb25zIHJlcXVpcmUgYWRkaXRpb25hbCByb3RhdGlvbiBieSAxODDCsDpcbiAgICAgIGlmIChyZXF1aXJlc1JvdDE4MChvcmllbnRhdGlvbiwgYXV0b09yaWVudGF0aW9uKSkge1xuICAgICAgICB2YXIgdG1wVG9wID0gdG9wXG4gICAgICAgIHZhciB0bXBSaWdodCA9IHJpZ2h0XG4gICAgICAgIHRvcCA9IGJvdHRvbVxuICAgICAgICByaWdodCA9IGxlZnRcbiAgICAgICAgYm90dG9tID0gdG1wVG9wXG4gICAgICAgIGxlZnQgPSB0bXBSaWdodFxuICAgICAgfVxuICAgIH1cbiAgICBuZXdPcHRpb25zLnRvcCA9IHRvcFxuICAgIG5ld09wdGlvbnMucmlnaHQgPSByaWdodFxuICAgIG5ld09wdGlvbnMuYm90dG9tID0gYm90dG9tXG4gICAgbmV3T3B0aW9ucy5sZWZ0ID0gbGVmdFxuICAgIC8vIEFjY291bnQgZm9yIGRlZmluZWQgYnJvd3NlciBvcmllbnRhdGlvbjpcbiAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIEhvcml6b250YWwgZmxpcFxuICAgICAgICBuZXdPcHRpb25zLnJpZ2h0ID0gbGVmdFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSByaWdodFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyAxODDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMucmlnaHQgPSBsZWZ0XG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gdG9wXG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IHJpZ2h0XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIFZlcnRpY2FsIGZsaXBcbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBib3R0b21cbiAgICAgICAgbmV3T3B0aW9ucy5ib3R0b20gPSB0b3BcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgLy8gVmVydGljYWwgZmxpcCArIDkwwrAgUm90YXRlIENXXG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gbGVmdFxuICAgICAgICBuZXdPcHRpb25zLnJpZ2h0ID0gYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gcmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gdG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIDkwwrAgUm90YXRlIENXXG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gcmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IGJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gdG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIEhvcml6b250YWwgZmxpcCArIDkwwrAgUm90YXRlIENXXG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gcmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IHRvcFxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gYm90dG9tXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDg6XG4gICAgICAgIC8vIDkwwrAgUm90YXRlIENDV1xuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IHRvcFxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IHJpZ2h0XG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IGJvdHRvbVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICByZXR1cm4gbmV3T3B0aW9uc1xuICB9XG5cbiAgLy8gVHJhbnNmb3JtIGltYWdlIG9yaWVudGF0aW9uIGJhc2VkIG9uIHRoZSBnaXZlbiBFWElGIG9yaWVudGF0aW9uIG9wdGlvbjpcbiAgbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGNhbnZhcywgb3B0aW9ucywgZGF0YSkge1xuICAgIG9yaWdpbmFsVHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbChsb2FkSW1hZ2UsIGNhbnZhcywgb3B0aW9ucywgZGF0YSlcbiAgICB2YXIgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uXG4gICAgdmFyIGF1dG9PcmllbnRhdGlvbiA9XG4gICAgICBsb2FkSW1hZ2Uub3JpZW50YXRpb24gJiYgZGF0YS5leGlmICYmIGRhdGEuZXhpZi5nZXQoJ09yaWVudGF0aW9uJylcbiAgICBpZiAoIXJlcXVpcmVzT3JpZW50YXRpb25DaGFuZ2Uob3JpZW50YXRpb24sIGF1dG9PcmllbnRhdGlvbikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICB2YXIgd2lkdGggPSBjYW52YXMud2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodFxuICAgIHZhciBzb3VyY2VXaWR0aCA9IHdpZHRoXG4gICAgdmFyIHNvdXJjZUhlaWdodCA9IGhlaWdodFxuICAgIGlmIChcbiAgICAgIChvcmllbnRhdGlvbiA+IDQgJiYgIShhdXRvT3JpZW50YXRpb24gPiA0KSkgfHxcbiAgICAgIChvcmllbnRhdGlvbiA8IDUgJiYgYXV0b09yaWVudGF0aW9uID4gNClcbiAgICApIHtcbiAgICAgIC8vIEltYWdlIGRpbWVuc2lvbnMgYW5kIHRhcmdldCBkaW1lbnNpb25zIGFyZSBzd2l0Y2hlZFxuICAgICAgY2FudmFzLndpZHRoID0gaGVpZ2h0XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGhcbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID4gNCkge1xuICAgICAgLy8gRGVzdGluYXRpb24gYW5kIHNvdXJjZSBkaW1lbnNpb25zIGFyZSBzd2l0Y2hlZFxuICAgICAgc291cmNlV2lkdGggPSBoZWlnaHRcbiAgICAgIHNvdXJjZUhlaWdodCA9IHdpZHRoXG4gICAgfVxuICAgIC8vIFJlc2V0IGF1dG9tYXRpYyBicm93c2VyIG9yaWVudGF0aW9uOlxuICAgIHN3aXRjaCAoYXV0b09yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIEhvcml6b250YWwgZmxpcFxuICAgICAgICBjdHgudHJhbnNsYXRlKHNvdXJjZVdpZHRoLCAwKVxuICAgICAgICBjdHguc2NhbGUoLTEsIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIDE4MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KVxuICAgICAgICBjdHgucm90YXRlKE1hdGguUEkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIFZlcnRpY2FsIGZsaXBcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBzb3VyY2VIZWlnaHQpXG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgLy8gSG9yaXpvbnRhbCBmbGlwICsgOTDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIGN0eC5yb3RhdGUoLTAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC5zY2FsZSgtMSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgLy8gOTDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIGN0eC5yb3RhdGUoLTAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXNvdXJjZVdpZHRoLCAwKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwICsgOTDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIGN0eC5yb3RhdGUoLTAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpXG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgLy8gOTDCsCBSb3RhdGUgQ1dcbiAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC1zb3VyY2VIZWlnaHQpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIC8vIFNvbWUgb3JpZW50YXRpb24gY29tYmluYXRpb25zIHJlcXVpcmUgYWRkaXRpb25hbCByb3RhdGlvbiBieSAxODDCsDpcbiAgICBpZiAocmVxdWlyZXNSb3QxODAob3JpZW50YXRpb24sIGF1dG9PcmllbnRhdGlvbikpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUoc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodClcbiAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSlcbiAgICB9XG4gICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXBcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMClcbiAgICAgICAgY3R4LnNjYWxlKC0xLCAxKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyAxODDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIGhlaWdodClcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0OlxuICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwXG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0KVxuICAgICAgICBjdHguc2NhbGUoMSwgLTEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8vIFZlcnRpY2FsIGZsaXAgKyA5MMKwIFJvdGF0ZSBDV1xuICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgLy8gOTDCsCBSb3RhdGUgQ1dcbiAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC1oZWlnaHQpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIEhvcml6b250YWwgZmxpcCArIDkwwrAgUm90YXRlIENXXG4gICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSlcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgLWhlaWdodClcbiAgICAgICAgY3R4LnNjYWxlKC0xLCAxKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA4OlxuICAgICAgICAvLyA5MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgY3R4LnJvdGF0ZSgtMC41ICogTWF0aC5QSSlcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtd2lkdGgsIDApXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-orientation.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-scale.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-scale.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n\n  loadImage.createCanvas = function (width, height, offscreen) {\n    if (offscreen && loadImage.global.OffscreenCanvas) {\n      return new OffscreenCanvas(width, height)\n    }\n    var canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    return canvas\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      loadImage.scale(img, options, data),\n      options,\n      callback,\n      file,\n      data\n    )\n  }\n\n  // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options and data passed as arguments:\n  loadImage.transformCoordinates = function () {}\n\n  // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options, data passed as arguments:\n  loadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio\n    var newOptions\n    var i\n    var width\n    var height\n    if (!aspectRatio) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.crop = true\n    width = img.naturalWidth || img.width\n    height = img.naturalHeight || img.height\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio\n      newOptions.maxHeight = height\n    } else {\n      newOptions.maxWidth = width\n      newOptions.maxHeight = width / aspectRatio\n    }\n    return newOptions\n  }\n\n  // Canvas render method, allows to implement a different rendering algorithm:\n  loadImage.drawImage = function (\n    img,\n    canvas,\n    sourceX,\n    sourceY,\n    sourceWidth,\n    sourceHeight,\n    destWidth,\n    destHeight,\n    options\n  ) {\n    var ctx = canvas.getContext('2d')\n    if (options.imageSmoothingEnabled === false) {\n      ctx.msImageSmoothingEnabled = false\n      ctx.imageSmoothingEnabled = false\n    } else if (options.imageSmoothingQuality) {\n      ctx.imageSmoothingQuality = options.imageSmoothingQuality\n    }\n    ctx.drawImage(\n      img,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      0,\n      0,\n      destWidth,\n      destHeight\n    )\n    return ctx\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.requiresCanvas = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio\n  }\n\n  // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options:\n  loadImage.scale = function (img, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var useCanvas =\n      img.getContext ||\n      (loadImage.requiresCanvas(options) &&\n        !!loadImage.global.HTMLCanvasElement)\n    var width = img.naturalWidth || img.width\n    var height = img.naturalHeight || img.height\n    var destWidth = width\n    var destHeight = height\n    var maxWidth\n    var maxHeight\n    var minWidth\n    var minHeight\n    var sourceWidth\n    var sourceHeight\n    var sourceX\n    var sourceY\n    var pixelRatio\n    var downsamplingRatio\n    var tmp\n    var canvas\n    /**\n     * Scales up image dimensions\n     */\n    function scaleUp() {\n      var scale = Math.max(\n        (minWidth || destWidth) / destWidth,\n        (minHeight || destHeight) / destHeight\n      )\n      if (scale > 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    /**\n     * Scales down image dimensions\n     */\n    function scaleDown() {\n      var scale = Math.min(\n        (maxWidth || destWidth) / destWidth,\n        (maxHeight || destHeight) / destHeight\n      )\n      if (scale < 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    if (useCanvas) {\n      // eslint-disable-next-line no-param-reassign\n      options = loadImage.getTransformedOptions(img, options, data)\n      sourceX = options.left || 0\n      sourceY = options.top || 0\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0)\n      }\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0)\n      }\n      destWidth = sourceWidth\n      destHeight = sourceHeight\n    }\n    maxWidth = options.maxWidth\n    maxHeight = options.maxHeight\n    minWidth = options.minWidth\n    minHeight = options.minHeight\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth\n      destHeight = maxHeight\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\n      if (tmp < 0) {\n        sourceHeight = (maxHeight * sourceWidth) / maxWidth\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2\n        }\n      } else if (tmp > 0) {\n        sourceWidth = (maxWidth * sourceHeight) / maxHeight\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth\n        minHeight = maxHeight = maxHeight || minHeight\n      }\n      if (options.cover) {\n        scaleDown()\n        scaleUp()\n      } else {\n        scaleUp()\n        scaleDown()\n      }\n    }\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio\n      if (\n        pixelRatio > 1 &&\n        // Check if the image has not yet had the device pixel ratio applied:\n        !(\n          img.style.width &&\n          Math.floor(parseFloat(img.style.width, 10)) ===\n            Math.floor(width / pixelRatio)\n        )\n      ) {\n        destWidth *= pixelRatio\n        destHeight *= pixelRatio\n      }\n      // Check if workaround for Chromium orientation crop bug is required:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074354\n      if (\n        loadImage.orientationCropBug &&\n        !img.getContext &&\n        (sourceX || sourceY || sourceWidth !== width || sourceHeight !== height)\n      ) {\n        // Write the complete source image to an intermediate canvas first:\n        tmp = img\n        // eslint-disable-next-line no-param-reassign\n        img = loadImage.createCanvas(width, height, true)\n        loadImage.drawImage(\n          tmp,\n          img,\n          0,\n          0,\n          width,\n          height,\n          width,\n          height,\n          options\n        )\n      }\n      downsamplingRatio = options.downsamplingRatio\n      if (\n        downsamplingRatio > 0 &&\n        downsamplingRatio < 1 &&\n        destWidth < sourceWidth &&\n        destHeight < sourceHeight\n      ) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas = loadImage.createCanvas(\n            sourceWidth * downsamplingRatio,\n            sourceHeight * downsamplingRatio,\n            true\n          )\n          loadImage.drawImage(\n            img,\n            canvas,\n            sourceX,\n            sourceY,\n            sourceWidth,\n            sourceHeight,\n            canvas.width,\n            canvas.height,\n            options\n          )\n          sourceX = 0\n          sourceY = 0\n          sourceWidth = canvas.width\n          sourceHeight = canvas.height\n          // eslint-disable-next-line no-param-reassign\n          img = canvas\n        }\n      }\n      canvas = loadImage.createCanvas(destWidth, destHeight)\n      loadImage.transformCoordinates(canvas, options, data)\n      if (pixelRatio > 1) {\n        canvas.style.width = canvas.width / pixelRatio + 'px'\n      }\n      loadImage\n        .drawImage(\n          img,\n          canvas,\n          sourceX,\n          sourceY,\n          sourceWidth,\n          sourceHeight,\n          destWidth,\n          destHeight,\n          options\n        )\n        .setTransform(1, 0, 0, 1, 0, 0) // reset to the identity matrix\n      return canvas\n    }\n    img.width = destWidth\n    img.height = destHeight\n    return img\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDckMsSUFBSSxLQUFLLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1zY2FsZS5qcz9kMTk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgU2NhbGluZ1xuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIG9yaWdpbmFsVHJhbnNmb3JtID0gbG9hZEltYWdlLnRyYW5zZm9ybVxuXG4gIGxvYWRJbWFnZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgb2Zmc2NyZWVuKSB7XG4gICAgaWYgKG9mZnNjcmVlbiAmJiBsb2FkSW1hZ2UuZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodClcbiAgICB9XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgcmV0dXJuIGNhbnZhc1xuICB9XG5cbiAgbG9hZEltYWdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChpbWcsIG9wdGlvbnMsIGNhbGxiYWNrLCBmaWxlLCBkYXRhKSB7XG4gICAgb3JpZ2luYWxUcmFuc2Zvcm0uY2FsbChcbiAgICAgIGxvYWRJbWFnZSxcbiAgICAgIGxvYWRJbWFnZS5zY2FsZShpbWcsIG9wdGlvbnMsIGRhdGEpLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgZmlsZSxcbiAgICAgIGRhdGFcbiAgICApXG4gIH1cblxuICAvLyBUcmFuc2Zvcm0gaW1hZ2UgY29vcmRpbmF0ZXMsIGFsbG93cyB0byBvdmVycmlkZSBlLmcuXG4gIC8vIHRoZSBjYW52YXMgb3JpZW50YXRpb24gYmFzZWQgb24gdGhlIG9yaWVudGF0aW9uIG9wdGlvbixcbiAgLy8gZ2V0cyBjYW52YXMsIG9wdGlvbnMgYW5kIGRhdGEgcGFzc2VkIGFzIGFyZ3VtZW50czpcbiAgbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKCkge31cblxuICAvLyBSZXR1cm5zIHRyYW5zZm9ybWVkIG9wdGlvbnMsIGFsbG93cyB0byBvdmVycmlkZSBlLmcuXG4gIC8vIG1heFdpZHRoLCBtYXhIZWlnaHQgYW5kIGNyb3Agb3B0aW9ucyBiYXNlZCBvbiB0aGUgYXNwZWN0UmF0aW8uXG4gIC8vIGdldHMgaW1nLCBvcHRpb25zLCBkYXRhIHBhc3NlZCBhcyBhcmd1bWVudHM6XG4gIGxvYWRJbWFnZS5nZXRUcmFuc2Zvcm1lZE9wdGlvbnMgPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zKSB7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpb1xuICAgIHZhciBuZXdPcHRpb25zXG4gICAgdmFyIGlcbiAgICB2YXIgd2lkdGhcbiAgICB2YXIgaGVpZ2h0XG4gICAgaWYgKCFhc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIG9wdGlvbnNcbiAgICB9XG4gICAgbmV3T3B0aW9ucyA9IHt9XG4gICAgZm9yIChpIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcbiAgICAgICAgbmV3T3B0aW9uc1tpXSA9IG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICB9XG4gICAgbmV3T3B0aW9ucy5jcm9wID0gdHJ1ZVxuICAgIHdpZHRoID0gaW1nLm5hdHVyYWxXaWR0aCB8fCBpbWcud2lkdGhcbiAgICBoZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodCB8fCBpbWcuaGVpZ2h0XG4gICAgaWYgKHdpZHRoIC8gaGVpZ2h0ID4gYXNwZWN0UmF0aW8pIHtcbiAgICAgIG5ld09wdGlvbnMubWF4V2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpb1xuICAgICAgbmV3T3B0aW9ucy5tYXhIZWlnaHQgPSBoZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3T3B0aW9ucy5tYXhXaWR0aCA9IHdpZHRoXG4gICAgICBuZXdPcHRpb25zLm1heEhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW9cbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnNcbiAgfVxuXG4gIC8vIENhbnZhcyByZW5kZXIgbWV0aG9kLCBhbGxvd3MgdG8gaW1wbGVtZW50IGEgZGlmZmVyZW50IHJlbmRlcmluZyBhbGdvcml0aG06XG4gIGxvYWRJbWFnZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbiAoXG4gICAgaW1nLFxuICAgIGNhbnZhcyxcbiAgICBzb3VyY2VYLFxuICAgIHNvdXJjZVksXG4gICAgc291cmNlV2lkdGgsXG4gICAgc291cmNlSGVpZ2h0LFxuICAgIGRlc3RXaWR0aCxcbiAgICBkZXN0SGVpZ2h0LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgaWYgKG9wdGlvbnMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2VcbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbWFnZVNtb290aGluZ1F1YWxpdHkpIHtcbiAgICAgIGN0eC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nUXVhbGl0eVxuICAgIH1cbiAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgaW1nLFxuICAgICAgc291cmNlWCxcbiAgICAgIHNvdXJjZVksXG4gICAgICBzb3VyY2VXaWR0aCxcbiAgICAgIHNvdXJjZUhlaWdodCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZGVzdFdpZHRoLFxuICAgICAgZGVzdEhlaWdodFxuICAgIClcbiAgICByZXR1cm4gY3R4XG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB0YXJnZXQgaW1hZ2Ugc2hvdWxkIGJlIGEgY2FudmFzIGVsZW1lbnQ6XG4gIGxvYWRJbWFnZS5yZXF1aXJlc0NhbnZhcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuY2FudmFzIHx8IG9wdGlvbnMuY3JvcCB8fCAhIW9wdGlvbnMuYXNwZWN0UmF0aW9cbiAgfVxuXG4gIC8vIFNjYWxlcyBhbmQvb3IgY3JvcHMgdGhlIGdpdmVuIGltYWdlIChpbWcgb3IgY2FudmFzIEhUTUwgZWxlbWVudClcbiAgLy8gdXNpbmcgdGhlIGdpdmVuIG9wdGlvbnM6XG4gIGxvYWRJbWFnZS5zY2FsZSA9IGZ1bmN0aW9uIChpbWcsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGRhdGEgPSBkYXRhIHx8IHt9XG4gICAgdmFyIHVzZUNhbnZhcyA9XG4gICAgICBpbWcuZ2V0Q29udGV4dCB8fFxuICAgICAgKGxvYWRJbWFnZS5yZXF1aXJlc0NhbnZhcyhvcHRpb25zKSAmJlxuICAgICAgICAhIWxvYWRJbWFnZS5nbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQpXG4gICAgdmFyIHdpZHRoID0gaW1nLm5hdHVyYWxXaWR0aCB8fCBpbWcud2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLmhlaWdodFxuICAgIHZhciBkZXN0V2lkdGggPSB3aWR0aFxuICAgIHZhciBkZXN0SGVpZ2h0ID0gaGVpZ2h0XG4gICAgdmFyIG1heFdpZHRoXG4gICAgdmFyIG1heEhlaWdodFxuICAgIHZhciBtaW5XaWR0aFxuICAgIHZhciBtaW5IZWlnaHRcbiAgICB2YXIgc291cmNlV2lkdGhcbiAgICB2YXIgc291cmNlSGVpZ2h0XG4gICAgdmFyIHNvdXJjZVhcbiAgICB2YXIgc291cmNlWVxuICAgIHZhciBwaXhlbFJhdGlvXG4gICAgdmFyIGRvd25zYW1wbGluZ1JhdGlvXG4gICAgdmFyIHRtcFxuICAgIHZhciBjYW52YXNcbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdXAgaW1hZ2UgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjYWxlVXAoKSB7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChcbiAgICAgICAgKG1pbldpZHRoIHx8IGRlc3RXaWR0aCkgLyBkZXN0V2lkdGgsXG4gICAgICAgIChtaW5IZWlnaHQgfHwgZGVzdEhlaWdodCkgLyBkZXN0SGVpZ2h0XG4gICAgICApXG4gICAgICBpZiAoc2NhbGUgPiAxKSB7XG4gICAgICAgIGRlc3RXaWR0aCAqPSBzY2FsZVxuICAgICAgICBkZXN0SGVpZ2h0ICo9IHNjYWxlXG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBkb3duIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsZURvd24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihcbiAgICAgICAgKG1heFdpZHRoIHx8IGRlc3RXaWR0aCkgLyBkZXN0V2lkdGgsXG4gICAgICAgIChtYXhIZWlnaHQgfHwgZGVzdEhlaWdodCkgLyBkZXN0SGVpZ2h0XG4gICAgICApXG4gICAgICBpZiAoc2NhbGUgPCAxKSB7XG4gICAgICAgIGRlc3RXaWR0aCAqPSBzY2FsZVxuICAgICAgICBkZXN0SGVpZ2h0ICo9IHNjYWxlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VDYW52YXMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgb3B0aW9ucyA9IGxvYWRJbWFnZS5nZXRUcmFuc2Zvcm1lZE9wdGlvbnMoaW1nLCBvcHRpb25zLCBkYXRhKVxuICAgICAgc291cmNlWCA9IG9wdGlvbnMubGVmdCB8fCAwXG4gICAgICBzb3VyY2VZID0gb3B0aW9ucy50b3AgfHwgMFxuICAgICAgaWYgKG9wdGlvbnMuc291cmNlV2lkdGgpIHtcbiAgICAgICAgc291cmNlV2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoXG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzb3VyY2VYID0gd2lkdGggLSBzb3VyY2VXaWR0aCAtIG9wdGlvbnMucmlnaHRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlV2lkdGggPSB3aWR0aCAtIHNvdXJjZVggLSAob3B0aW9ucy5yaWdodCB8fCAwKVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc291cmNlSGVpZ2h0KSB7XG4gICAgICAgIHNvdXJjZUhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0XG4gICAgICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzb3VyY2VZID0gaGVpZ2h0IC0gc291cmNlSGVpZ2h0IC0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlSGVpZ2h0ID0gaGVpZ2h0IC0gc291cmNlWSAtIChvcHRpb25zLmJvdHRvbSB8fCAwKVxuICAgICAgfVxuICAgICAgZGVzdFdpZHRoID0gc291cmNlV2lkdGhcbiAgICAgIGRlc3RIZWlnaHQgPSBzb3VyY2VIZWlnaHRcbiAgICB9XG4gICAgbWF4V2lkdGggPSBvcHRpb25zLm1heFdpZHRoXG4gICAgbWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHRcbiAgICBtaW5XaWR0aCA9IG9wdGlvbnMubWluV2lkdGhcbiAgICBtaW5IZWlnaHQgPSBvcHRpb25zLm1pbkhlaWdodFxuICAgIGlmICh1c2VDYW52YXMgJiYgbWF4V2lkdGggJiYgbWF4SGVpZ2h0ICYmIG9wdGlvbnMuY3JvcCkge1xuICAgICAgZGVzdFdpZHRoID0gbWF4V2lkdGhcbiAgICAgIGRlc3RIZWlnaHQgPSBtYXhIZWlnaHRcbiAgICAgIHRtcCA9IHNvdXJjZVdpZHRoIC8gc291cmNlSGVpZ2h0IC0gbWF4V2lkdGggLyBtYXhIZWlnaHRcbiAgICAgIGlmICh0bXAgPCAwKSB7XG4gICAgICAgIHNvdXJjZUhlaWdodCA9IChtYXhIZWlnaHQgKiBzb3VyY2VXaWR0aCkgLyBtYXhXaWR0aFxuICAgICAgICBpZiAob3B0aW9ucy50b3AgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmJvdHRvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWSA9IChoZWlnaHQgLSBzb3VyY2VIZWlnaHQpIC8gMlxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRtcCA+IDApIHtcbiAgICAgICAgc291cmNlV2lkdGggPSAobWF4V2lkdGggKiBzb3VyY2VIZWlnaHQpIC8gbWF4SGVpZ2h0XG4gICAgICAgIGlmIChvcHRpb25zLmxlZnQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzb3VyY2VYID0gKHdpZHRoIC0gc291cmNlV2lkdGgpIC8gMlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmNvbnRhaW4gfHwgb3B0aW9ucy5jb3Zlcikge1xuICAgICAgICBtaW5XaWR0aCA9IG1heFdpZHRoID0gbWF4V2lkdGggfHwgbWluV2lkdGhcbiAgICAgICAgbWluSGVpZ2h0ID0gbWF4SGVpZ2h0ID0gbWF4SGVpZ2h0IHx8IG1pbkhlaWdodFxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY292ZXIpIHtcbiAgICAgICAgc2NhbGVEb3duKClcbiAgICAgICAgc2NhbGVVcCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZVVwKClcbiAgICAgICAgc2NhbGVEb3duKClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZUNhbnZhcykge1xuICAgICAgcGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpb1xuICAgICAgaWYgKFxuICAgICAgICBwaXhlbFJhdGlvID4gMSAmJlxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW1hZ2UgaGFzIG5vdCB5ZXQgaGFkIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8gYXBwbGllZDpcbiAgICAgICAgIShcbiAgICAgICAgICBpbWcuc3R5bGUud2lkdGggJiZcbiAgICAgICAgICBNYXRoLmZsb29yKHBhcnNlRmxvYXQoaW1nLnN0eWxlLndpZHRoLCAxMCkpID09PVxuICAgICAgICAgICAgTWF0aC5mbG9vcih3aWR0aCAvIHBpeGVsUmF0aW8pXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBkZXN0V2lkdGggKj0gcGl4ZWxSYXRpb1xuICAgICAgICBkZXN0SGVpZ2h0ICo9IHBpeGVsUmF0aW9cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIHdvcmthcm91bmQgZm9yIENocm9taXVtIG9yaWVudGF0aW9uIGNyb3AgYnVnIGlzIHJlcXVpcmVkOlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA3NDM1NFxuICAgICAgaWYgKFxuICAgICAgICBsb2FkSW1hZ2Uub3JpZW50YXRpb25Dcm9wQnVnICYmXG4gICAgICAgICFpbWcuZ2V0Q29udGV4dCAmJlxuICAgICAgICAoc291cmNlWCB8fCBzb3VyY2VZIHx8IHNvdXJjZVdpZHRoICE9PSB3aWR0aCB8fCBzb3VyY2VIZWlnaHQgIT09IGhlaWdodClcbiAgICAgICkge1xuICAgICAgICAvLyBXcml0ZSB0aGUgY29tcGxldGUgc291cmNlIGltYWdlIHRvIGFuIGludGVybWVkaWF0ZSBjYW52YXMgZmlyc3Q6XG4gICAgICAgIHRtcCA9IGltZ1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgaW1nID0gbG9hZEltYWdlLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0LCB0cnVlKVxuICAgICAgICBsb2FkSW1hZ2UuZHJhd0ltYWdlKFxuICAgICAgICAgIHRtcCxcbiAgICAgICAgICBpbWcsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBkb3duc2FtcGxpbmdSYXRpbyA9IG9wdGlvbnMuZG93bnNhbXBsaW5nUmF0aW9cbiAgICAgIGlmIChcbiAgICAgICAgZG93bnNhbXBsaW5nUmF0aW8gPiAwICYmXG4gICAgICAgIGRvd25zYW1wbGluZ1JhdGlvIDwgMSAmJlxuICAgICAgICBkZXN0V2lkdGggPCBzb3VyY2VXaWR0aCAmJlxuICAgICAgICBkZXN0SGVpZ2h0IDwgc291cmNlSGVpZ2h0XG4gICAgICApIHtcbiAgICAgICAgd2hpbGUgKHNvdXJjZVdpZHRoICogZG93bnNhbXBsaW5nUmF0aW8gPiBkZXN0V2lkdGgpIHtcbiAgICAgICAgICBjYW52YXMgPSBsb2FkSW1hZ2UuY3JlYXRlQ2FudmFzKFxuICAgICAgICAgICAgc291cmNlV2lkdGggKiBkb3duc2FtcGxpbmdSYXRpbyxcbiAgICAgICAgICAgIHNvdXJjZUhlaWdodCAqIGRvd25zYW1wbGluZ1JhdGlvLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgICBsb2FkSW1hZ2UuZHJhd0ltYWdlKFxuICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VXaWR0aCxcbiAgICAgICAgICAgIHNvdXJjZUhlaWdodCxcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKVxuICAgICAgICAgIHNvdXJjZVggPSAwXG4gICAgICAgICAgc291cmNlWSA9IDBcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGNhbnZhcy53aWR0aFxuICAgICAgICAgIHNvdXJjZUhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICBpbWcgPSBjYW52YXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FudmFzID0gbG9hZEltYWdlLmNyZWF0ZUNhbnZhcyhkZXN0V2lkdGgsIGRlc3RIZWlnaHQpXG4gICAgICBsb2FkSW1hZ2UudHJhbnNmb3JtQ29vcmRpbmF0ZXMoY2FudmFzLCBvcHRpb25zLCBkYXRhKVxuICAgICAgaWYgKHBpeGVsUmF0aW8gPiAxKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8gKyAncHgnXG4gICAgICB9XG4gICAgICBsb2FkSW1hZ2VcbiAgICAgICAgLmRyYXdJbWFnZShcbiAgICAgICAgICBpbWcsXG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICBzb3VyY2VXaWR0aCxcbiAgICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgICAgZGVzdFdpZHRoLFxuICAgICAgICAgIGRlc3RIZWlnaHQsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICAgIC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCkgLy8gcmVzZXQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICAgICAgcmV0dXJuIGNhbnZhc1xuICAgIH1cbiAgICBpbWcud2lkdGggPSBkZXN0V2lkdGhcbiAgICBpbWcuaGVpZ2h0ID0gZGVzdEhlaWdodFxuICAgIHJldHVybiBpbWdcbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-scale.js\n"));

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image.js":
/*!**********************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, Promise */\n\n;(function ($) {\n  'use strict'\n\n  var urlAPI = $.URL || $.webkitURL\n\n  /**\n   * Creates an object URL for a given File object.\n   *\n   * @param {Blob} blob Blob object\n   * @returns {string|boolean} Returns object URL if API exists, else false.\n   */\n  function createObjectURL(blob) {\n    return urlAPI ? urlAPI.createObjectURL(blob) : false\n  }\n\n  /**\n   * Revokes a given object URL.\n   *\n   * @param {string} url Blob object URL\n   * @returns {undefined|boolean} Returns undefined if API exists, else false.\n   */\n  function revokeObjectURL(url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false\n  }\n\n  /**\n   * Helper function to revoke an object URL\n   *\n   * @param {string} url Blob Object URL\n   * @param {object} [options] Options object\n   */\n  function revokeHelper(url, options) {\n    if (url && url.slice(0, 5) === 'blob:' && !(options && options.noRevoke)) {\n      revokeObjectURL(url)\n    }\n  }\n\n  /**\n   * Loads a given File object via FileReader interface.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} onload Load event callback\n   * @param {Function} [onerror] Error/Abort event callback\n   * @param {string} [method=readAsDataURL] FileReader method\n   * @returns {FileReader|boolean} Returns FileReader if API exists, else false.\n   */\n  function readFile(file, onload, onerror, method) {\n    if (!$.FileReader) return false\n    var reader = new FileReader()\n    reader.onload = function () {\n      onload.call(reader, this.result)\n    }\n    if (onerror) {\n      reader.onabort = reader.onerror = function () {\n        onerror.call(reader, this.error)\n      }\n    }\n    var readerMethod = reader[method || 'readAsDataURL']\n    if (readerMethod) {\n      readerMethod.call(reader, file)\n      return reader\n    }\n  }\n\n  /**\n   * Cross-frame instanceof check.\n   *\n   * @param {string} type Instance type\n   * @param {object} obj Object instance\n   * @returns {boolean} Returns true if the object is of the given instance.\n   */\n  function isInstanceOf(type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']'\n  }\n\n  /**\n   * @typedef { HTMLImageElement|HTMLCanvasElement } Result\n   */\n\n  /**\n   * Loads an image for a given File object.\n   *\n   * @param {Blob|string} file Blob object or image URL\n   * @param {Function|object} [callback] Image load event callback or options\n   * @param {object} [options] Options object\n   * @returns {HTMLImageElement|FileReader|Promise<Result>} Object\n   */\n  function loadImage(file, callback, options) {\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {HTMLImageElement|FileReader} Object\n     */\n    function executor(resolve, reject) {\n      var img = document.createElement('img')\n      var url\n      /**\n       * Callback for the fetchBlob call.\n       *\n       * @param {HTMLImageElement|HTMLCanvasElement} img Error object\n       * @param {object} data Data object\n       * @returns {undefined} Undefined\n       */\n      function resolveWrapper(img, data) {\n        if (resolve === reject) {\n          // Not using Promises\n          if (resolve) resolve(img, data)\n          return\n        } else if (img instanceof Error) {\n          reject(img)\n          return\n        }\n        data = data || {} // eslint-disable-line no-param-reassign\n        data.image = img\n        resolve(data)\n      }\n      /**\n       * Callback for the fetchBlob call.\n       *\n       * @param {Blob} blob Blob object\n       * @param {Error} err Error object\n       */\n      function fetchBlobCallback(blob, err) {\n        if (err && $.console) console.log(err) // eslint-disable-line no-console\n        if (blob && isInstanceOf('Blob', blob)) {\n          file = blob // eslint-disable-line no-param-reassign\n          url = createObjectURL(file)\n        } else {\n          url = file\n          if (options && options.crossOrigin) {\n            img.crossOrigin = options.crossOrigin\n          }\n        }\n        img.src = url\n      }\n      img.onerror = function (event) {\n        revokeHelper(url, options)\n        if (reject) reject.call(img, event)\n      }\n      img.onload = function () {\n        revokeHelper(url, options)\n        var data = {\n          originalWidth: img.naturalWidth || img.width,\n          originalHeight: img.naturalHeight || img.height\n        }\n        try {\n          loadImage.transform(img, options, resolveWrapper, file, data)\n        } catch (error) {\n          if (reject) reject(error)\n        }\n      }\n      if (typeof file === 'string') {\n        if (loadImage.requiresMetaData(options)) {\n          loadImage.fetchBlob(file, fetchBlobCallback, options)\n        } else {\n          fetchBlobCallback()\n        }\n        return img\n      } else if (isInstanceOf('Blob', file) || isInstanceOf('File', file)) {\n        url = createObjectURL(file)\n        if (url) {\n          img.src = url\n          return img\n        }\n        return readFile(\n          file,\n          function (url) {\n            img.src = url\n          },\n          reject\n        )\n      }\n    }\n    if ($.Promise && typeof callback !== 'function') {\n      options = callback // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    return executor(callback, callback)\n  }\n\n  // Determines if metadata should be loaded automatically.\n  // Requires the load image meta extension to load metadata.\n  loadImage.requiresMetaData = function (options) {\n    return options && options.meta\n  }\n\n  // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n  loadImage.fetchBlob = function (url, callback) {\n    callback()\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    callback(img, data)\n  }\n\n  loadImage.global = $\n  loadImage.readFile = readFile\n  loadImage.isInstanceOf = isInstanceOf\n  loadImage.createObjectURL = createObjectURL\n  loadImage.revokeObjectURL = revokeObjectURL\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return loadImage\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})((typeof window !== 'undefined' && window) || this)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsNkNBQTZDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JELGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxtQ0FBTztBQUNYO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sSUFBSSxLQUFLLEVBSU47QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS5qcz9mNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIFByb21pc2UgKi9cblxuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgdXJsQVBJID0gJC5VUkwgfHwgJC53ZWJraXRVUkxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgVVJMIGZvciBhIGdpdmVuIEZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgQmxvYiBvYmplY3RcbiAgICogQHJldHVybnMge3N0cmluZ3xib29sZWFufSBSZXR1cm5zIG9iamVjdCBVUkwgaWYgQVBJIGV4aXN0cywgZWxzZSBmYWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChibG9iKSB7XG4gICAgcmV0dXJuIHVybEFQSSA/IHVybEFQSS5jcmVhdGVPYmplY3RVUkwoYmxvYikgOiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldm9rZXMgYSBnaXZlbiBvYmplY3QgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIEJsb2Igb2JqZWN0IFVSTFxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IFJldHVybnMgdW5kZWZpbmVkIGlmIEFQSSBleGlzdHMsIGVsc2UgZmFsc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZXZva2VPYmplY3RVUkwodXJsKSB7XG4gICAgcmV0dXJuIHVybEFQSSA/IHVybEFQSS5yZXZva2VPYmplY3RVUkwodXJsKSA6IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldm9rZSBhbiBvYmplY3QgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgQmxvYiBPYmplY3QgVVJMXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIHJldm9rZUhlbHBlcih1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAodXJsICYmIHVybC5zbGljZSgwLCA1KSA9PT0gJ2Jsb2I6JyAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Jldm9rZSkpIHtcbiAgICAgIHJldm9rZU9iamVjdFVSTCh1cmwpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgZ2l2ZW4gRmlsZSBvYmplY3QgdmlhIEZpbGVSZWFkZXIgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGZpbGUgQmxvYiBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIExvYWQgZXZlbnQgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uZXJyb3JdIEVycm9yL0Fib3J0IGV2ZW50IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPXJlYWRBc0RhdGFVUkxdIEZpbGVSZWFkZXIgbWV0aG9kXG4gICAqIEByZXR1cm5zIHtGaWxlUmVhZGVyfGJvb2xlYW59IFJldHVybnMgRmlsZVJlYWRlciBpZiBBUEkgZXhpc3RzLCBlbHNlIGZhbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZSwgb25sb2FkLCBvbmVycm9yLCBtZXRob2QpIHtcbiAgICBpZiAoISQuRmlsZVJlYWRlcikgcmV0dXJuIGZhbHNlXG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgb25sb2FkLmNhbGwocmVhZGVyLCB0aGlzLnJlc3VsdClcbiAgICB9XG4gICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgIHJlYWRlci5vbmFib3J0ID0gcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uZXJyb3IuY2FsbChyZWFkZXIsIHRoaXMuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZWFkZXJNZXRob2QgPSByZWFkZXJbbWV0aG9kIHx8ICdyZWFkQXNEYXRhVVJMJ11cbiAgICBpZiAocmVhZGVyTWV0aG9kKSB7XG4gICAgICByZWFkZXJNZXRob2QuY2FsbChyZWFkZXIsIGZpbGUpXG4gICAgICByZXR1cm4gcmVhZGVyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyb3NzLWZyYW1lIGluc3RhbmNlb2YgY2hlY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEluc3RhbmNlIHR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgaW5zdGFuY2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbiBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzSW5zdGFuY2VPZih0eXBlLCBvYmopIHtcbiAgICAvLyBDcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGNoZWNrXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJ1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudCB9IFJlc3VsdFxuICAgKi9cblxuICAvKipcbiAgICogTG9hZHMgYW4gaW1hZ2UgZm9yIGEgZ2l2ZW4gRmlsZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYnxzdHJpbmd9IGZpbGUgQmxvYiBvYmplY3Qgb3IgaW1hZ2UgVVJMXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258b2JqZWN0fSBbY2FsbGJhY2tdIEltYWdlIGxvYWQgZXZlbnQgY2FsbGJhY2sgb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fEZpbGVSZWFkZXJ8UHJvbWlzZTxSZXN1bHQ+fSBPYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGxvYWRJbWFnZShmaWxlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIFByb21pc2UgZXhlY3V0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgUmVzb2x1dGlvbiBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBSZWplY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudHxGaWxlUmVhZGVyfSBPYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgdmFyIHVybFxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayBmb3IgdGhlIGZldGNoQmxvYiBjYWxsLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gaW1nIEVycm9yIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IFVuZGVmaW5lZFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlV3JhcHBlcihpbWcsIGRhdGEpIHtcbiAgICAgICAgaWYgKHJlc29sdmUgPT09IHJlamVjdCkge1xuICAgICAgICAgIC8vIE5vdCB1c2luZyBQcm9taXNlc1xuICAgICAgICAgIGlmIChyZXNvbHZlKSByZXNvbHZlKGltZywgZGF0YSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmIChpbWcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJlamVjdChpbWcpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBkYXRhLmltYWdlID0gaW1nXG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgZm9yIHRoZSBmZXRjaEJsb2IgY2FsbC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgQmxvYiBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBFcnJvciBvYmplY3RcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZmV0Y2hCbG9iQ2FsbGJhY2soYmxvYiwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgJC5jb25zb2xlKSBjb25zb2xlLmxvZyhlcnIpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBpZiAoYmxvYiAmJiBpc0luc3RhbmNlT2YoJ0Jsb2InLCBibG9iKSkge1xuICAgICAgICAgIGZpbGUgPSBibG9iIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZmlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwgPSBmaWxlXG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbWcuc3JjID0gdXJsXG4gICAgICB9XG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXZva2VIZWxwZXIodXJsLCBvcHRpb25zKVxuICAgICAgICBpZiAocmVqZWN0KSByZWplY3QuY2FsbChpbWcsIGV2ZW50KVxuICAgICAgfVxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV2b2tlSGVscGVyKHVybCwgb3B0aW9ucylcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgb3JpZ2luYWxXaWR0aDogaW1nLm5hdHVyYWxXaWR0aCB8fCBpbWcud2lkdGgsXG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IGltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRJbWFnZS50cmFuc2Zvcm0oaW1nLCBvcHRpb25zLCByZXNvbHZlV3JhcHBlciwgZmlsZSwgZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAocmVqZWN0KSByZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGxvYWRJbWFnZS5yZXF1aXJlc01ldGFEYXRhKG9wdGlvbnMpKSB7XG4gICAgICAgICAgbG9hZEltYWdlLmZldGNoQmxvYihmaWxlLCBmZXRjaEJsb2JDYWxsYmFjaywgb3B0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaEJsb2JDYWxsYmFjaygpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltZ1xuICAgICAgfSBlbHNlIGlmIChpc0luc3RhbmNlT2YoJ0Jsb2InLCBmaWxlKSB8fCBpc0luc3RhbmNlT2YoJ0ZpbGUnLCBmaWxlKSkge1xuICAgICAgICB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZmlsZSlcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIGltZy5zcmMgPSB1cmxcbiAgICAgICAgICByZXR1cm4gaW1nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlKFxuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCQuUHJvbWlzZSAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSBjYWxsYmFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgfVxuICAgIHJldHVybiBleGVjdXRvcihjYWxsYmFjaywgY2FsbGJhY2spXG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIG1ldGFkYXRhIHNob3VsZCBiZSBsb2FkZWQgYXV0b21hdGljYWxseS5cbiAgLy8gUmVxdWlyZXMgdGhlIGxvYWQgaW1hZ2UgbWV0YSBleHRlbnNpb24gdG8gbG9hZCBtZXRhZGF0YS5cbiAgbG9hZEltYWdlLnJlcXVpcmVzTWV0YURhdGEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubWV0YVxuICB9XG5cbiAgLy8gSWYgdGhlIGNhbGxiYWNrIGdpdmVuIHRvIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGJsb2IsIGl0IGlzIHVzZWQgYXMgaW1hZ2VcbiAgLy8gc291cmNlIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHVybCBhbmQgb3ZlcnJpZGVzIHRoZSBmaWxlIGFyZ3VtZW50IHVzZWQgaW5cbiAgLy8gdGhlIG9ubG9hZCBhbmQgb25lcnJvciBldmVudCBjYWxsYmFja3M6XG4gIGxvYWRJbWFnZS5mZXRjaEJsb2IgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIGxvYWRJbWFnZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zLCBjYWxsYmFjaywgZmlsZSwgZGF0YSkge1xuICAgIGNhbGxiYWNrKGltZywgZGF0YSlcbiAgfVxuXG4gIGxvYWRJbWFnZS5nbG9iYWwgPSAkXG4gIGxvYWRJbWFnZS5yZWFkRmlsZSA9IHJlYWRGaWxlXG4gIGxvYWRJbWFnZS5pc0luc3RhbmNlT2YgPSBpc0luc3RhbmNlT2ZcbiAgbG9hZEltYWdlLmNyZWF0ZU9iamVjdFVSTCA9IGNyZWF0ZU9iamVjdFVSTFxuICBsb2FkSW1hZ2UucmV2b2tlT2JqZWN0VVJMID0gcmV2b2tlT2JqZWN0VVJMXG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbG9hZEltYWdlXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbG9hZEltYWdlXG4gIH0gZWxzZSB7XG4gICAgJC5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2VcbiAgfVxufSkoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHwgdGhpcylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image.js\n"));

/***/ }),

/***/ "./src/containers/AddSimpleRestroomContainer.tsx":
/*!*******************************************************!*\
  !*** ./src/containers/AddSimpleRestroomContainer.tsx ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_node_modules_next_dist_compiled_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _app_node_modules_next_dist_compiled_babel_runtime_helpers_esm_objectWithoutProperties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/objectWithoutProperties.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var blueimp_load_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blueimp-load-image */ \"./node_modules/blueimp-load-image/js/index.js\");\n/* harmony import */ var blueimp_load_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(blueimp_load_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-hook-form */ \"./node_modules/react-hook-form/dist/index.esm.mjs\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! swr */ \"./node_modules/swr/dist/core/index.mjs\");\n/* harmony import */ var _presentationals_AddSimpleRestroom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/presentationals/AddSimpleRestroom */ \"./src/presentationals/AddSimpleRestroom.tsx\");\n/* harmony import */ var _emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @emotion/react/jsx-dev-runtime */ \"./node_modules/@emotion/react/jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js\");\n\n\nvar _excluded = [\"ref\"];\nvar _jsxFileName = \"/app/src/containers/AddSimpleRestroomContainer.tsx\",\n  _this = undefined,\n  _s = $RefreshSig$();\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_app_node_modules_next_dist_compiled_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n\n\n\n\n\n\n\nvar AddSimpleRestroomContainer = function AddSimpleRestroomContainer(_ref) {\n  _s();\n  var open = _ref.open,\n    onClose = _ref.onClose;\n  var _useForm = (0,react_hook_form__WEBPACK_IMPORTED_MODULE_6__.useForm)({\n      defaultValues: {\n        name: '',\n        address: '',\n        content: '',\n        nursing_room: false,\n        anyone_toilet: false,\n        diaper_changing_station: false,\n        powder_corner: false,\n        stroller_accessible: false,\n        latitude: 35.681236,\n        longitude: 139.767125\n      }\n    }),\n    register = _useForm.register,\n    handleSubmit = _useForm.handleSubmit,\n    control = _useForm.control,\n    reset = _useForm.reset;\n  var fileInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null); //更新可能\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(''),\n    fileName = _useState[0],\n    setFileName = _useState[1];\n  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(''),\n    imageData = _useState2[0],\n    setImageData = _useState2[1];\n  var onChange = function onChange(e) {\n    var files = e.target.files;\n    if (!files || files.length <= 0) return;\n    showImageFileName(files);\n  };\n\n  // ref関数 react-hook-formが管理できるようになる\n  var _register = register('image', {\n      onChange: onChange\n    }),\n    ref = _register.ref,\n    rest = (0,_app_node_modules_next_dist_compiled_babel_runtime_helpers_esm_objectWithoutProperties_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_register, _excluded);\n  var selectImageFile = function selectImageFile() {\n    if (!fileInput.current) return;\n    fileInput.current.removeAttribute('capture');\n    fileInput.current.click();\n  };\n  var showImageFileName = function showImageFileName(files) {\n    var file = files[0];\n    var fileReader = new FileReader();\n    setFileName(file.name);\n    fileReader.onload = function () {\n      setImageData(fileReader.result);\n    };\n    fileReader.readAsDataURL(file);\n  };\n  var resetImageFile = function resetImageFile() {\n    setFileName('');\n    setImageData('');\n    if (fileInput.current) {\n      fileInput.current.value = '';\n    }\n  };\n  var resetModal = function resetModal() {\n    reset();\n    resetImageFile();\n    onClose();\n  };\n  var getExifData = function getExifData(file) {\n    blueimp_load_image__WEBPACK_IMPORTED_MODULE_2___default().parseMetaData(file, function (data) {\n      console.log(data);\n      console.log('Exif data: ', data.exif);\n    });\n  };\n  var onSubmit = function onSubmit(data) {\n    var _data$nursing_room, _data$anyone_toilet, _data$diaper_changing, _data$powder_corner, _data$stroller_access, _fileInput$current;\n    var formData = new FormData();\n    formData.append('post[name]', data.name);\n    formData.append('post[address]', data.address);\n    formData.append('post[content]', data.content);\n    formData.append('post[latitude]', data.latitude.toString());\n    formData.append('post[longitude]', data.longitude.toString());\n    formData.append('post[nursing_room]', ((_data$nursing_room = data.nursing_room) !== null && _data$nursing_room !== void 0 ? _data$nursing_room : false).toString());\n    formData.append('post[anyone_toilet]', ((_data$anyone_toilet = data.anyone_toilet) !== null && _data$anyone_toilet !== void 0 ? _data$anyone_toilet : false).toString());\n    formData.append('post[diaper_changing_station]', ((_data$diaper_changing = data.diaper_changing_station) !== null && _data$diaper_changing !== void 0 ? _data$diaper_changing : false).toString());\n    formData.append('post[powder_corner]', ((_data$powder_corner = data.powder_corner) !== null && _data$powder_corner !== void 0 ? _data$powder_corner : false).toString());\n    formData.append('post[stroller_accessible]', ((_data$stroller_access = data.stroller_accessible) !== null && _data$stroller_access !== void 0 ? _data$stroller_access : false).toString());\n    if ((_fileInput$current = fileInput.current) !== null && _fileInput$current !== void 0 && _fileInput$current.files && fileInput.current.files[0]) {\n      formData.append('post[image]', fileInput.current.files[0]);\n    }\n    var getUrl = \"http://localhost:3000/api/v1\" + '/posts';\n    var headers = {\n      'Content-Type': 'multipart/form-data'\n    };\n    axios__WEBPACK_IMPORTED_MODULE_7__[\"default\"].post(getUrl, formData, {\n      headers: headers\n    }).then(function (res) {\n      console.log('Data submitted successfully', res.data);\n      (0,swr__WEBPACK_IMPORTED_MODULE_4__.mutate)(getUrl);\n      resetModal();\n    })[\"catch\"](function (e) {\n      var _e$response;\n      console.error(\"Request failed with status code \".concat((_e$response = e.response) === null || _e$response === void 0 ? void 0 : _e$response.status));\n      console.error(e.message);\n    });\n  };\n  return (0,_emotion_react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxDEV)(_presentationals_AddSimpleRestroom__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n    open: open,\n    onClose: resetModal\n    // coords={coords}\n    ,\n    handleSubmit: handleSubmit,\n    onSubmit: onSubmit,\n    control: control,\n    fileName: fileName,\n    imageData: imageData,\n    selectImageFile: selectImageFile,\n    resetImageFile: resetImageFile,\n    register: _objectSpread(_objectSpread({}, rest), {}, {\n      ref: ref\n    }),\n    fileInput: fileInput,\n    onChange: onChange //ファイル分割用に追加\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 148,\n    columnNumber: 5\n  }, _this);\n};\n_s(AddSimpleRestroomContainer, \"WcmFNdp9dReWFbKTLgqo/dNqO6E=\", false, function () {\n  return [react_hook_form__WEBPACK_IMPORTED_MODULE_6__.useForm];\n});\n_c = AddSimpleRestroomContainer;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AddSimpleRestroomContainer);\nvar _c;\n$RefreshReg$(_c, \"AddSimpleRestroomContainer\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udGFpbmVycy9BZGRTaW1wbGVSZXN0cm9vbUNvbnRhaW5lci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDZDtBQUNnQjtBQUNGO0FBQzVCO0FBQ3VDO0FBQUE7QUFzQm5FLElBQU1TLDBCQUE0RCxHQUFHLFNBQS9EQSwwQkFBNERBLENBQUFDLElBQUEsRUFHNUQ7RUFBQUMsRUFBQTtFQUFBLElBRkpDLElBQUksR0FBQUYsSUFBQSxDQUFKRSxJQUFJO0lBQ0pDLE9BQU8sR0FBQUgsSUFBQSxDQUFQRyxPQUFPO0VBRVAsSUFBQUMsUUFBQSxHQUNFVix3REFBTyxDQUE0QjtNQUNqQ1csYUFBYSxFQUFFO1FBQ2JDLElBQUksRUFBRSxFQUFFO1FBQ1JDLE9BQU8sRUFBRSxFQUFFO1FBQ1hDLE9BQU8sRUFBRSxFQUFFO1FBQ1hDLFlBQVksRUFBRSxLQUFLO1FBQ25CQyxhQUFhLEVBQUUsS0FBSztRQUNwQkMsdUJBQXVCLEVBQUUsS0FBSztRQUM5QkMsYUFBYSxFQUFFLEtBQUs7UUFDcEJDLG1CQUFtQixFQUFFLEtBQUs7UUFDMUJDLFFBQVEsRUFBRSxTQUFTO1FBQ25CQyxTQUFTLEVBQUU7TUFDYjtJQUNGLENBQUMsQ0FBQztJQWRJQyxRQUFRLEdBQUFaLFFBQUEsQ0FBUlksUUFBUTtJQUFFQyxZQUFZLEdBQUFiLFFBQUEsQ0FBWmEsWUFBWTtJQUFFQyxPQUFPLEdBQUFkLFFBQUEsQ0FBUGMsT0FBTztJQUFFQyxLQUFLLEdBQUFmLFFBQUEsQ0FBTGUsS0FBSztFQWdCOUMsSUFBTUMsU0FBUyxHQUFHM0IsNkNBQU0sQ0FDdEIsSUFDRixDQUF1QyxFQUFDO0VBQ3hDLElBQUE0QixTQUFBLEdBQWdDN0IsK0NBQVEsQ0FBQyxFQUFFLENBQUM7SUFBckM4QixRQUFRLEdBQUFELFNBQUE7SUFBRUUsV0FBVyxHQUFBRixTQUFBO0VBQzVCLElBQUFHLFVBQUEsR0FBa0NoQywrQ0FBUSxDQUFDLEVBQUUsQ0FBQztJQUF2Q2lDLFNBQVMsR0FBQUQsVUFBQTtJQUFFRSxZQUFZLEdBQUFGLFVBQUE7RUFFOUIsSUFBTUcsUUFBUSxHQUFHLFNBQVhBLFFBQVFBLENBQUlDLENBQXNDLEVBQUs7SUFDM0QsSUFBTUMsS0FBSyxHQUFHRCxDQUFDLENBQUNFLE1BQU0sQ0FBQ0QsS0FBSztJQUM1QixJQUFJLENBQUNBLEtBQUssSUFBSUEsS0FBSyxDQUFDRSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ2pDQyxpQkFBaUIsQ0FBQ0gsS0FBSyxDQUFDO0VBQzFCLENBQUM7O0VBRUQ7RUFDQSxJQUFBSSxTQUFBLEdBQXlCakIsUUFBUSxDQUFDLE9BQU8sRUFBRTtNQUFFVyxRQUFRLEVBQVJBO0lBQVMsQ0FBQyxDQUFDO0lBQWhETyxHQUFHLEdBQUFELFNBQUEsQ0FBSEMsR0FBRztJQUFLQyxJQUFJLEdBQUFDLHFJQUFBLENBQUFILFNBQUEsRUFBQUksU0FBQTtFQUVwQixJQUFNQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWVBLENBQUEsRUFBUztJQUM1QixJQUFJLENBQUNsQixTQUFTLENBQUNtQixPQUFPLEVBQUU7SUFDeEJuQixTQUFTLENBQUNtQixPQUFPLENBQUNDLGVBQWUsQ0FBQyxTQUFTLENBQUM7SUFDNUNwQixTQUFTLENBQUNtQixPQUFPLENBQUNFLEtBQUssQ0FBQyxDQUFDO0VBQzNCLENBQUM7RUFFRCxJQUFNVCxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQWlCQSxDQUFJSCxLQUFlLEVBQUs7SUFDN0MsSUFBTWEsSUFBSSxHQUFHYixLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLElBQU1jLFVBQVUsR0FBRyxJQUFJQyxVQUFVLENBQUMsQ0FBQztJQUNuQ3JCLFdBQVcsQ0FBQ21CLElBQUksQ0FBQ3BDLElBQUksQ0FBQztJQUN0QnFDLFVBQVUsQ0FBQ0UsTUFBTSxHQUFHLFlBQU07TUFDeEJuQixZQUFZLENBQUNpQixVQUFVLENBQUNHLE1BQWdCLENBQUM7SUFDM0MsQ0FBQztJQUNESCxVQUFVLENBQUNJLGFBQWEsQ0FBQ0wsSUFBSSxDQUFDO0VBQ2hDLENBQUM7RUFFRCxJQUFNTSxjQUFjLEdBQUcsU0FBakJBLGNBQWNBLENBQUEsRUFBUztJQUMzQnpCLFdBQVcsQ0FBQyxFQUFFLENBQUM7SUFDZkcsWUFBWSxDQUFDLEVBQUUsQ0FBQztJQUNoQixJQUFJTixTQUFTLENBQUNtQixPQUFPLEVBQUU7TUFDckJuQixTQUFTLENBQUNtQixPQUFPLENBQUNVLEtBQUssR0FBRyxFQUFFO0lBQzlCO0VBQ0YsQ0FBQztFQUVELElBQU1DLFVBQVUsR0FBRyxTQUFiQSxVQUFVQSxDQUFBLEVBQVM7SUFDdkIvQixLQUFLLENBQUMsQ0FBQztJQUNQNkIsY0FBYyxDQUFDLENBQUM7SUFDaEI3QyxPQUFPLENBQUMsQ0FBQztFQUNYLENBQUM7RUFFRCxJQUFNZ0QsV0FBVyxHQUFHLFNBQWRBLFdBQVdBLENBQUlULElBQVUsRUFBSztJQUNsQ25ELHVFQUF1QixDQUFDbUQsSUFBSSxFQUFFLFVBQUNXLElBQUksRUFBSztNQUN0Q0MsT0FBTyxDQUFDQyxHQUFHLENBQUNGLElBQUksQ0FBQztNQUNqQkMsT0FBTyxDQUFDQyxHQUFHLENBQUMsYUFBYSxFQUFFRixJQUFJLENBQUNHLElBQUksQ0FBQztJQUN2QyxDQUFDLENBQUM7RUFDSixDQUFDO0VBRUQsSUFBTUMsUUFBa0QsR0FBRyxTQUFyREEsUUFBa0RBLENBQUlKLElBQUksRUFBSztJQUFBLElBQUFLLGtCQUFBLEVBQUFDLG1CQUFBLEVBQUFDLHFCQUFBLEVBQUFDLG1CQUFBLEVBQUFDLHFCQUFBLEVBQUFDLGtCQUFBO0lBQ25FLElBQU1DLFFBQVEsR0FBRyxJQUFJQyxRQUFRLENBQUMsQ0FBQztJQUMvQkQsUUFBUSxDQUFDRSxNQUFNLENBQUMsWUFBWSxFQUFFYixJQUFJLENBQUMvQyxJQUFJLENBQUM7SUFDeEMwRCxRQUFRLENBQUNFLE1BQU0sQ0FBQyxlQUFlLEVBQUViLElBQUksQ0FBQzlDLE9BQU8sQ0FBQztJQUM5Q3lELFFBQVEsQ0FBQ0UsTUFBTSxDQUFDLGVBQWUsRUFBRWIsSUFBSSxDQUFDN0MsT0FBTyxDQUFDO0lBQzlDd0QsUUFBUSxDQUFDRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUViLElBQUksQ0FBQ3ZDLFFBQVEsQ0FBQ3FELFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0RILFFBQVEsQ0FBQ0UsTUFBTSxDQUFDLGlCQUFpQixFQUFFYixJQUFJLENBQUN0QyxTQUFTLENBQUNvRCxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzdESCxRQUFRLENBQUNFLE1BQU0sQ0FDYixvQkFBb0IsRUFDcEIsRUFBQVIsa0JBQUEsR0FBQ0wsSUFBSSxDQUFDNUMsWUFBWSxjQUFBaUQsa0JBQUEsY0FBQUEsa0JBQUEsR0FBSSxLQUFLLEVBQUVTLFFBQVEsQ0FBQyxDQUN4QyxDQUFDO0lBQ0RILFFBQVEsQ0FBQ0UsTUFBTSxDQUNiLHFCQUFxQixFQUNyQixFQUFBUCxtQkFBQSxHQUFDTixJQUFJLENBQUMzQyxhQUFhLGNBQUFpRCxtQkFBQSxjQUFBQSxtQkFBQSxHQUFJLEtBQUssRUFBRVEsUUFBUSxDQUFDLENBQ3pDLENBQUM7SUFDREgsUUFBUSxDQUFDRSxNQUFNLENBQ2IsK0JBQStCLEVBQy9CLEVBQUFOLHFCQUFBLEdBQUNQLElBQUksQ0FBQzFDLHVCQUF1QixjQUFBaUQscUJBQUEsY0FBQUEscUJBQUEsR0FBSSxLQUFLLEVBQUVPLFFBQVEsQ0FBQyxDQUNuRCxDQUFDO0lBQ0RILFFBQVEsQ0FBQ0UsTUFBTSxDQUNiLHFCQUFxQixFQUNyQixFQUFBTCxtQkFBQSxHQUFDUixJQUFJLENBQUN6QyxhQUFhLGNBQUFpRCxtQkFBQSxjQUFBQSxtQkFBQSxHQUFJLEtBQUssRUFBRU0sUUFBUSxDQUFDLENBQ3pDLENBQUM7SUFDREgsUUFBUSxDQUFDRSxNQUFNLENBQ2IsMkJBQTJCLEVBQzNCLEVBQUFKLHFCQUFBLEdBQUNULElBQUksQ0FBQ3hDLG1CQUFtQixjQUFBaUQscUJBQUEsY0FBQUEscUJBQUEsR0FBSSxLQUFLLEVBQUVLLFFBQVEsQ0FBQyxDQUMvQyxDQUFDO0lBQ0QsSUFBSSxDQUFBSixrQkFBQSxHQUFBM0MsU0FBUyxDQUFDbUIsT0FBTyxjQUFBd0Isa0JBQUEsZUFBakJBLGtCQUFBLENBQW1CbEMsS0FBSyxJQUFJVCxTQUFTLENBQUNtQixPQUFPLENBQUNWLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUMxRG1DLFFBQVEsQ0FBQ0UsTUFBTSxDQUFDLGFBQWEsRUFBRTlDLFNBQVMsQ0FBQ21CLE9BQU8sQ0FBQ1YsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVEO0lBRUEsSUFBTXVDLE1BQU0sR0FBR0MsOEJBQW9DLEdBQUcsUUFBUTtJQUM5RCxJQUFNRyxPQUFPLEdBQUc7TUFBRSxjQUFjLEVBQUU7SUFBc0IsQ0FBQztJQUV6RGxGLGtEQUNPLENBQUM4RSxNQUFNLEVBQUVKLFFBQVEsRUFBRTtNQUFFUSxPQUFPLEVBQVBBO0lBQVEsQ0FBQyxDQUFDLENBQ25DRSxJQUFJLENBQUMsVUFBQ0MsR0FBa0IsRUFBSztNQUM1QnJCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDZCQUE2QixFQUFFb0IsR0FBRyxDQUFDdEIsSUFBSSxDQUFDO01BQ3BEMUQsMkNBQU0sQ0FBQ3lFLE1BQU0sQ0FBQztNQUNkbEIsVUFBVSxDQUFDLENBQUM7SUFDZCxDQUFDLENBQUMsU0FDSSxDQUFDLFVBQUN0QixDQUFnQyxFQUFLO01BQUEsSUFBQWdELFdBQUE7TUFDM0N0QixPQUFPLENBQUN1QixLQUFLLG9DQUFBQyxNQUFBLEVBQUFGLFdBQUEsR0FBb0NoRCxDQUFDLENBQUNtRCxRQUFRLGNBQUFILFdBQUEsdUJBQVZBLFdBQUEsQ0FBWUksTUFBTSxDQUFFLENBQUM7TUFDdEUxQixPQUFPLENBQUN1QixLQUFLLENBQUNqRCxDQUFDLENBQUNxRCxPQUFPLENBQUM7SUFDMUIsQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUVELE9BQ0VuRixzRUFBQSxDQUFDRiwwRUFBaUI7SUFDaEJNLElBQUksRUFBRUEsSUFBSztJQUNYQyxPQUFPLEVBQUUrQztJQUNUO0lBQUE7SUFDQWpDLFlBQVksRUFBRUEsWUFBYTtJQUMzQndDLFFBQVEsRUFBRUEsUUFBUztJQUNuQnZDLE9BQU8sRUFBRUEsT0FBUTtJQUNqQkksUUFBUSxFQUFFQSxRQUFTO0lBQ25CRyxTQUFTLEVBQUVBLFNBQVU7SUFDckJhLGVBQWUsRUFBRUEsZUFBZ0I7SUFDakNVLGNBQWMsRUFBRUEsY0FBZTtJQUMvQmhDLFFBQVEsRUFBQWtFLGFBQUEsQ0FBQUEsYUFBQSxLQUFPL0MsSUFBSTtNQUFFRCxHQUFHLEVBQUhBO0lBQUcsRUFBRztJQUMzQmQsU0FBUyxFQUFFQSxTQUFVO0lBQ3JCTyxRQUFRLEVBQUVBLFFBQVMsQ0FBQztFQUFBO0lBQUFMLFFBQUEsRUFBQTZELFlBQUE7SUFBQUMsVUFBQTtJQUFBQyxZQUFBO0VBQUEsR0FBQUMsS0FDckIsQ0FBQztBQUVOLENBQUM7QUFBQXJGLEVBQUEsQ0F4SUtGLDBCQUE0RDtFQUFBLFFBSzlETCxvREFBTztBQUFBO0FBQUE2RixFQUFBLEdBTEx4RiwwQkFBNEQ7QUEwSWxFLCtEQUFlQSwwQkFBMEI7QUFBQSxJQUFBd0YsRUFBQTtBQUFBQyxZQUFBLENBQUFELEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRhaW5lcnMvQWRkU2ltcGxlUmVzdHJvb21Db250YWluZXIudHN4PzBiMjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zLCB7IEF4aW9zUmVzcG9uc2UsIEF4aW9zRXJyb3IgfSBmcm9tICdheGlvcydcbmltcG9ydCBsb2FkSW1hZ2UgZnJvbSAnYmx1ZWltcC1sb2FkLWltYWdlJ1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgTXV0YWJsZVJlZk9iamVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlRm9ybSwgU3VibWl0SGFuZGxlciB9IGZyb20gJ3JlYWN0LWhvb2stZm9ybSdcbmltcG9ydCB7IG11dGF0ZSB9IGZyb20gJ3N3cidcbmltcG9ydCBBZGRTaW1wbGVSZXN0cm9vbSBmcm9tICdAL3ByZXNlbnRhdGlvbmFscy9BZGRTaW1wbGVSZXN0cm9vbSdcblxuaW50ZXJmYWNlIEFkZFNpbXBsZVJlc3Ryb29tRm9ybURhdGEge1xuICBuYW1lOiBzdHJpbmdcbiAgYWRkcmVzczogc3RyaW5nXG4gIGNvbnRlbnQ6IHN0cmluZ1xuICBsYXRpdHVkZTogbnVtYmVyXG4gIGxvbmdpdHVkZTogbnVtYmVyXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIG51cnNpbmdfcm9vbTogYm9vbGVhblxuICBhbnlvbmVfdG9pbGV0OiBib29sZWFuXG4gIGRpYXBlcl9jaGFuZ2luZ19zdGF0aW9uOiBib29sZWFuXG4gIHBvd2Rlcl9jb3JuZXI6IGJvb2xlYW5cbiAgc3Ryb2xsZXJfYWNjZXNzaWJsZTogYm9vbGVhblxuICBpbWFnZT86IEZpbGVMaXN0XG59XG5cbmludGVyZmFjZSBBZGRTaW1wbGVSZXN0cm9vbVByb3BzIHtcbiAgb3BlbjogYm9vbGVhblxuICBvbkNsb3NlOiAoKSA9PiB2b2lkXG59XG5cbmNvbnN0IEFkZFNpbXBsZVJlc3Ryb29tQ29udGFpbmVyOiBSZWFjdC5GQzxBZGRTaW1wbGVSZXN0cm9vbVByb3BzPiA9ICh7XG4gIG9wZW4sXG4gIG9uQ2xvc2UsXG59KSA9PiB7XG4gIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgY29udHJvbCwgcmVzZXQgfSA9XG4gICAgdXNlRm9ybTxBZGRTaW1wbGVSZXN0cm9vbUZvcm1EYXRhPih7XG4gICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICBhZGRyZXNzOiAnJyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIG51cnNpbmdfcm9vbTogZmFsc2UsXG4gICAgICAgIGFueW9uZV90b2lsZXQ6IGZhbHNlLFxuICAgICAgICBkaWFwZXJfY2hhbmdpbmdfc3RhdGlvbjogZmFsc2UsXG4gICAgICAgIHBvd2Rlcl9jb3JuZXI6IGZhbHNlLFxuICAgICAgICBzdHJvbGxlcl9hY2Nlc3NpYmxlOiBmYWxzZSxcbiAgICAgICAgbGF0aXR1ZGU6IDM1LjY4MTIzNixcbiAgICAgICAgbG9uZ2l0dWRlOiAxMzkuNzY3MTI1LFxuICAgICAgfSxcbiAgICB9KVxuXG4gIGNvbnN0IGZpbGVJbnB1dCA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihcbiAgICBudWxsLFxuICApIGFzIE11dGFibGVSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD4gLy/mm7TmlrDlj6/og71cbiAgY29uc3QgW2ZpbGVOYW1lLCBzZXRGaWxlTmFtZV0gPSB1c2VTdGF0ZSgnJylcbiAgY29uc3QgW2ltYWdlRGF0YSwgc2V0SW1hZ2VEYXRhXSA9IHVzZVN0YXRlKCcnKVxuXG4gIGNvbnN0IG9uQ2hhbmdlID0gKGU6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgZmlsZXMgPSBlLnRhcmdldC5maWxlc1xuICAgIGlmICghZmlsZXMgfHwgZmlsZXMubGVuZ3RoIDw9IDApIHJldHVyblxuICAgIHNob3dJbWFnZUZpbGVOYW1lKGZpbGVzKVxuICB9XG5cbiAgLy8gcmVm6Zai5pWwIHJlYWN0LWhvb2stZm9ybeOBjOeuoeeQhuOBp+OBjeOCi+OCiOOBhuOBq+OBquOCi1xuICBjb25zdCB7IHJlZiwgLi4ucmVzdCB9ID0gcmVnaXN0ZXIoJ2ltYWdlJywgeyBvbkNoYW5nZSB9KVxuXG4gIGNvbnN0IHNlbGVjdEltYWdlRmlsZSA9ICgpID0+IHtcbiAgICBpZiAoIWZpbGVJbnB1dC5jdXJyZW50KSByZXR1cm5cbiAgICBmaWxlSW5wdXQuY3VycmVudC5yZW1vdmVBdHRyaWJ1dGUoJ2NhcHR1cmUnKVxuICAgIGZpbGVJbnB1dC5jdXJyZW50LmNsaWNrKClcbiAgfVxuXG4gIGNvbnN0IHNob3dJbWFnZUZpbGVOYW1lID0gKGZpbGVzOiBGaWxlTGlzdCkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSBmaWxlc1swXVxuICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgc2V0RmlsZU5hbWUoZmlsZS5uYW1lKVxuICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgc2V0SW1hZ2VEYXRhKGZpbGVSZWFkZXIucmVzdWx0IGFzIHN0cmluZylcbiAgICB9XG4gICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gIH1cblxuICBjb25zdCByZXNldEltYWdlRmlsZSA9ICgpID0+IHtcbiAgICBzZXRGaWxlTmFtZSgnJylcbiAgICBzZXRJbWFnZURhdGEoJycpXG4gICAgaWYgKGZpbGVJbnB1dC5jdXJyZW50KSB7XG4gICAgICBmaWxlSW5wdXQuY3VycmVudC52YWx1ZSA9ICcnXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzZXRNb2RhbCA9ICgpID0+IHtcbiAgICByZXNldCgpXG4gICAgcmVzZXRJbWFnZUZpbGUoKVxuICAgIG9uQ2xvc2UoKVxuICB9XG5cbiAgY29uc3QgZ2V0RXhpZkRhdGEgPSAoZmlsZTogRmlsZSkgPT4ge1xuICAgIGxvYWRJbWFnZS5wYXJzZU1ldGFEYXRhKGZpbGUsIChkYXRhKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgY29uc29sZS5sb2coJ0V4aWYgZGF0YTogJywgZGF0YS5leGlmKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBvblN1Ym1pdDogU3VibWl0SGFuZGxlcjxBZGRTaW1wbGVSZXN0cm9vbUZvcm1EYXRhPiA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgIGZvcm1EYXRhLmFwcGVuZCgncG9zdFtuYW1lXScsIGRhdGEubmFtZSlcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3Bvc3RbYWRkcmVzc10nLCBkYXRhLmFkZHJlc3MpXG4gICAgZm9ybURhdGEuYXBwZW5kKCdwb3N0W2NvbnRlbnRdJywgZGF0YS5jb250ZW50KVxuICAgIGZvcm1EYXRhLmFwcGVuZCgncG9zdFtsYXRpdHVkZV0nLCBkYXRhLmxhdGl0dWRlLnRvU3RyaW5nKCkpXG4gICAgZm9ybURhdGEuYXBwZW5kKCdwb3N0W2xvbmdpdHVkZV0nLCBkYXRhLmxvbmdpdHVkZS50b1N0cmluZygpKVxuICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICdwb3N0W251cnNpbmdfcm9vbV0nLFxuICAgICAgKGRhdGEubnVyc2luZ19yb29tID8/IGZhbHNlKS50b1N0cmluZygpLFxuICAgIClcbiAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAncG9zdFthbnlvbmVfdG9pbGV0XScsXG4gICAgICAoZGF0YS5hbnlvbmVfdG9pbGV0ID8/IGZhbHNlKS50b1N0cmluZygpLFxuICAgIClcbiAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAncG9zdFtkaWFwZXJfY2hhbmdpbmdfc3RhdGlvbl0nLFxuICAgICAgKGRhdGEuZGlhcGVyX2NoYW5naW5nX3N0YXRpb24gPz8gZmFsc2UpLnRvU3RyaW5nKCksXG4gICAgKVxuICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICdwb3N0W3Bvd2Rlcl9jb3JuZXJdJyxcbiAgICAgIChkYXRhLnBvd2Rlcl9jb3JuZXIgPz8gZmFsc2UpLnRvU3RyaW5nKCksXG4gICAgKVxuICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICdwb3N0W3N0cm9sbGVyX2FjY2Vzc2libGVdJyxcbiAgICAgIChkYXRhLnN0cm9sbGVyX2FjY2Vzc2libGUgPz8gZmFsc2UpLnRvU3RyaW5nKCksXG4gICAgKVxuICAgIGlmIChmaWxlSW5wdXQuY3VycmVudD8uZmlsZXMgJiYgZmlsZUlucHV0LmN1cnJlbnQuZmlsZXNbMF0pIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgncG9zdFtpbWFnZV0nLCBmaWxlSW5wdXQuY3VycmVudC5maWxlc1swXSlcbiAgICB9XG5cbiAgICBjb25zdCBnZXRVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwgKyAnL3Bvc3RzJ1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgfVxuXG4gICAgYXhpb3NcbiAgICAgIC5wb3N0KGdldFVybCwgZm9ybURhdGEsIHsgaGVhZGVycyB9KVxuICAgICAgLnRoZW4oKHJlczogQXhpb3NSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnRGF0YSBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5JywgcmVzLmRhdGEpXG4gICAgICAgIG11dGF0ZShnZXRVcmwpXG4gICAgICAgIHJlc2V0TW9kYWwoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZTogQXhpb3NFcnJvcjx7IGVycm9yOiBzdHJpbmcgfT4pID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2UucmVzcG9uc2U/LnN0YXR1c31gKVxuICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSlcbiAgICAgIH0pXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxBZGRTaW1wbGVSZXN0cm9vbVxuICAgICAgb3Blbj17b3Blbn1cbiAgICAgIG9uQ2xvc2U9e3Jlc2V0TW9kYWx9XG4gICAgICAvLyBjb29yZHM9e2Nvb3Jkc31cbiAgICAgIGhhbmRsZVN1Ym1pdD17aGFuZGxlU3VibWl0fVxuICAgICAgb25TdWJtaXQ9e29uU3VibWl0fVxuICAgICAgY29udHJvbD17Y29udHJvbH1cbiAgICAgIGZpbGVOYW1lPXtmaWxlTmFtZX1cbiAgICAgIGltYWdlRGF0YT17aW1hZ2VEYXRhfVxuICAgICAgc2VsZWN0SW1hZ2VGaWxlPXtzZWxlY3RJbWFnZUZpbGV9XG4gICAgICByZXNldEltYWdlRmlsZT17cmVzZXRJbWFnZUZpbGV9XG4gICAgICByZWdpc3Rlcj17eyAuLi5yZXN0LCByZWYgfX1cbiAgICAgIGZpbGVJbnB1dD17ZmlsZUlucHV0fVxuICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfSAvL+ODleOCoeOCpOODq+WIhuWJsueUqOOBq+i/veWKoFxuICAgIC8+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWRkU2ltcGxlUmVzdHJvb21Db250YWluZXJcbiJdLCJuYW1lcyI6WyJheGlvcyIsImxvYWRJbWFnZSIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRm9ybSIsIm11dGF0ZSIsIkFkZFNpbXBsZVJlc3Ryb29tIiwianN4REVWIiwiX2pzeERFViIsIkFkZFNpbXBsZVJlc3Ryb29tQ29udGFpbmVyIiwiX3JlZiIsIl9zIiwib3BlbiIsIm9uQ2xvc2UiLCJfdXNlRm9ybSIsImRlZmF1bHRWYWx1ZXMiLCJuYW1lIiwiYWRkcmVzcyIsImNvbnRlbnQiLCJudXJzaW5nX3Jvb20iLCJhbnlvbmVfdG9pbGV0IiwiZGlhcGVyX2NoYW5naW5nX3N0YXRpb24iLCJwb3dkZXJfY29ybmVyIiwic3Ryb2xsZXJfYWNjZXNzaWJsZSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwicmVnaXN0ZXIiLCJoYW5kbGVTdWJtaXQiLCJjb250cm9sIiwicmVzZXQiLCJmaWxlSW5wdXQiLCJfdXNlU3RhdGUiLCJmaWxlTmFtZSIsInNldEZpbGVOYW1lIiwiX3VzZVN0YXRlMiIsImltYWdlRGF0YSIsInNldEltYWdlRGF0YSIsIm9uQ2hhbmdlIiwiZSIsImZpbGVzIiwidGFyZ2V0IiwibGVuZ3RoIiwic2hvd0ltYWdlRmlsZU5hbWUiLCJfcmVnaXN0ZXIiLCJyZWYiLCJyZXN0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwic2VsZWN0SW1hZ2VGaWxlIiwiY3VycmVudCIsInJlbW92ZUF0dHJpYnV0ZSIsImNsaWNrIiwiZmlsZSIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsInJlc2V0SW1hZ2VGaWxlIiwidmFsdWUiLCJyZXNldE1vZGFsIiwiZ2V0RXhpZkRhdGEiLCJwYXJzZU1ldGFEYXRhIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJleGlmIiwib25TdWJtaXQiLCJfZGF0YSRudXJzaW5nX3Jvb20iLCJfZGF0YSRhbnlvbmVfdG9pbGV0IiwiX2RhdGEkZGlhcGVyX2NoYW5naW5nIiwiX2RhdGEkcG93ZGVyX2Nvcm5lciIsIl9kYXRhJHN0cm9sbGVyX2FjY2VzcyIsIl9maWxlSW5wdXQkY3VycmVudCIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJ0b1N0cmluZyIsImdldFVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwiLCJoZWFkZXJzIiwicG9zdCIsInRoZW4iLCJyZXMiLCJfZSRyZXNwb25zZSIsImVycm9yIiwiY29uY2F0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJtZXNzYWdlIiwiX29iamVjdFNwcmVhZCIsIl9qc3hGaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJfdGhpcyIsIl9jIiwiJFJlZnJlc2hSZWckIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/containers/AddSimpleRestroomContainer.tsx\n"));

/***/ })

});